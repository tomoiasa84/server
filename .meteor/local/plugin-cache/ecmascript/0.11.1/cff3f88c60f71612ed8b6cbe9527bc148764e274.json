{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/herteby:denormalize/cache.js","filename":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","presets":[],"generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/herteby:denormalize/cache.js"}},"code":"module.export({\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration, migrate, autoMigrate;\nmodule.watch(require(\"./migrations.js\"), {\n  addMigration(v) {\n    addMigration = v;\n  },\n\n  migrate(v) {\n    migrate = v;\n  },\n\n  autoMigrate(v) {\n    autoMigrate = v;\n  }\n\n}, 1);\n\nfunction flattenFields(object, prefix) {\n  prefix = prefix || '';\n  let fields = [];\n\n  _.each(object, (val, key) => {\n    if (typeof val == 'object') {\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'));\n    } else {\n      fields.push(prefix + key);\n    }\n  });\n\n  return fields;\n}\n\nMongo.Collection.prototype.cache = function (options) {\n  check(options, {\n    collection: Match.Where(collection => collection instanceof Mongo.Collection),\n    fields: Match.OneOf([String], Object),\n    type: Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField: String,\n    cacheField: String,\n    bypassSchema: Match.Optional(Boolean)\n  });\n  if (options.type == 'inverse') options.type = 'inversed'; //Not sure which is best, so why not support both and be typo-friendly\n\n  if (options.type == 'many-inverse') options.type = 'many-inversed'; //Bypass collection2 schemas\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let type = options.type;\n  let referenceField = options.referenceField;\n  let cacheField = options.cacheField;\n  let watchedFields = options.fields;\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  if (!_.isArray(watchedFields)) {\n    watchedFields = flattenFields(watchedFields);\n  }\n\n  let childFields = _.clone(watchedFields);\n\n  if (type !== 'one') {\n    if (!_.includes(childFields, '_id')) {\n      childFields.push('_id');\n    }\n\n    _.pull(childFields, referenceField);\n  }\n\n  let childOpts = {\n    transform: null,\n    fields: {\n      _id: 0\n    }\n  };\n\n  _.each(childFields, field => childOpts.fields[field] = 1);\n\n  let parentOpts = {\n    transform: null,\n    fields: {\n      _id: 1,\n      [cacheField]: 1\n    }\n  };\n\n  if (type !== 'inversed' && type !== 'many-inversed') {\n    parentOpts.fields[referenceField.split(':')[0]] = 1;\n  }\n\n  let idField, referencePath;\n\n  if (type == 'many' || type == 'many-inversed') {\n    referencePath = referenceField.replace(':', '.');\n    idField = referenceField.split(':')[1];\n    referenceField = referenceField.split(':')[0];\n  }\n\n  if (type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)) {\n    watchedFields.push(referencePath || referenceField);\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]));\n\n  function getNestedReferences(document) {\n    //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || [];\n\n    if (idField && references.length) {\n      references = _.map(references, item => _.get(item, idField));\n    }\n\n    return _.uniq(_.flatten(references));\n  }\n\n  if (type == 'one') {\n    let insert = function insert(userId, parent) {\n      if (_.get(parent, referenceField)) {\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        }\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $unset: {\n              [cacheField]: 1\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $set: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          [referenceField]: child._id\n        }, {\n          $set: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $unset: {\n          [cacheField]: 1\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'many') {\n    let insert = function insert(userId, parent) {\n      let references = getNestedReferences(parent);\n\n      if (references.length) {\n        let children = childCollection.find({\n          _id: {\n            $in: references\n          }\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      } else {\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: []\n          }\n        });\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let references = getNestedReferences(parent);\n\n        if (references.length) {\n          let children = childCollection.find({\n            _id: {\n              $in: references\n            }\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $push: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.find({\n          [referencePath]: child._id\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referenceField]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        if (_.get(parent, referenceField)) {\n          let children = childCollection.find({\n            [referenceField]: parent._id\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      if (_.get(child, referenceField)) {\n        parentCollection.update({\n          _id: _.get(child, referenceField)\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        let previousId = this.previous && _.get(this.previous, referenceField);\n\n        if (previousId && previousId !== _.get(child, referenceField)) {\n          parentCollection.update({\n            _id: previousId\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          });\n        }\n\n        parentCollection.find({\n          _id: _.get(child, referenceField)\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        _id: _.get(child, referenceField)\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      });\n    });\n  } else if (type == 'many-inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referencePath]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let children = childCollection.find({\n          [referencePath]: parent._id\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let references = getNestedReferences(child);\n        let previousIds = this.previous && getNestedReferences(this.previous);\n        previousIds = _.difference(previousIds, references);\n\n        if (previousIds.length) {\n          parentCollection.update({\n            _id: {\n              $in: previousIds\n            }\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          }, {\n            multi: true\n          });\n        }\n\n        if (references.length) {\n          let pickedChild = _.pick(child, childFields);\n\n          parentCollection.find({\n            _id: {\n              $in: references\n            }\n          }, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {\n              _id: child._id\n            });\n\n            if (index > -1) {\n              parentCollection.update(parent._id, {\n                $set: {\n                  [cacheField + '.' + index]: pickedChild\n                }\n              });\n            } else {\n              parentCollection.update(parent._id, {\n                $push: {\n                  [cacheField]: pickedChild\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $pull: {\n            [cacheField]: {\n              _id: child._id\n            }\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n  }\n};","map":{"version":3,"sources":["packages/herteby:denormalize/cache.js"],"names":["module","export","migrate","autoMigrate","_","watch","require","default","v","addMigration","flattenFields","object","prefix","fields","each","val","key","union","push","Mongo","Collection","prototype","cache","options","check","collection","Match","Where","OneOf","String","Object","type","referenceField","cacheField","bypassSchema","Optional","Boolean","parentCollection","Package","_collection","childCollection","watchedFields","split","Error","isArray","childFields","clone","includes","pull","childOpts","transform","_id","field","parentOpts","idField","referencePath","replace","topFields","uniq","map","getNestedReferences","document","references","get","length","item","flatten","insert","userId","parent","child","findOne","update","$set","after","changedFields","$unset","pickedChild","pick","multi","intersection","remove","children","find","$in","fetch","$push","forEach","index","findIndex","$pull","previousId","previous","previousIds","difference"],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport {addMigration, migrate, autoMigrate} from './migrations.js'\n\nexport {migrate, autoMigrate}\n\nfunction flattenFields(object, prefix){\n  prefix = prefix || ''\n  let fields = []\n  _.each(object, (val, key) => {\n    if(typeof val == 'object'){\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'))\n    } else {\n      fields.push(prefix + key)\n    }\n  })\n  return fields\n}\n\nMongo.Collection.prototype.cache = function(options){\n  check(options, {\n    collection:Match.Where(collection => collection instanceof Mongo.Collection),\n    fields:Match.OneOf([String], Object),\n    type:Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField:String,\n    cacheField:String,\n    bypassSchema:Match.Optional(Boolean)\n  })\n  if(options.type == 'inverse') options.type = 'inversed' //Not sure which is best, so why not support both and be typo-friendly\n  if(options.type == 'many-inverse') options.type = 'many-inversed'\n\n  //Bypass collection2 schemas\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let type = options.type\n  let referenceField = options.referenceField\n  let cacheField = options.cacheField\n  let watchedFields = options.fields\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  if(!_.isArray(watchedFields)){\n    watchedFields = flattenFields(watchedFields)\n  }\n\n  let childFields = _.clone(watchedFields)\n  if(type !== 'one'){\n    if(!_.includes(childFields, '_id')){\n      childFields.push('_id')\n    }\n    _.pull(childFields, referenceField)\n  }\n  let childOpts = {transform:null, fields:{_id:0}}\n  _.each(childFields, field => childOpts.fields[field] = 1)\n\n  let parentOpts = {transform:null, fields:{_id:1, [cacheField]:1}}\n  if(type !== 'inversed' && type !== 'many-inversed'){\n    parentOpts.fields[referenceField.split(':')[0]] = 1\n  }\n\n  let idField, referencePath\n  if(type == 'many' || type == 'many-inversed'){\n    referencePath = referenceField.replace(':', '.')\n    idField = referenceField.split(':')[1]\n    referenceField = referenceField.split(':')[0]\n  }\n\n  if(type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)){\n    watchedFields.push(referencePath || referenceField)\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]))\n\n  function getNestedReferences(document){ //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || []\n    if(idField && references.length){\n      references = _.map(references, item => _.get(item, idField))\n    }\n    return _.uniq(_.flatten(references))\n  }\n\n\n  if(type == 'one'){\n    let insert = function insert(userId, parent){\n      if(_.get(parent, referenceField)){\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        }\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        } else {\n          parentCollection.update(parent._id, {$unset:{[cacheField]:1}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referenceField]:child._id}, {$unset:{[cacheField]:1}}, {multi:true})\n    })\n  } \n\n  else if(type == 'many'){\n    let insert = function insert(userId, parent){\n      let references = getNestedReferences(parent)\n      if(references.length){\n        let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      } else {\n        parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let references = getNestedReferences(parent)\n        if(references.length){\n          let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referencePath]:child._id}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.find({[referencePath]:child._id}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referencePath]:child._id}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n    })\n  }\n\n\n  else if(type == 'inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        if(_.get(parent, referenceField)){\n          let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      if(_.get(child, referenceField)){\n        parentCollection.update({_id:_.get(child, referenceField)}, {$push:{[cacheField]:pickedChild}})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        let previousId = this.previous && _.get(this.previous, referenceField)\n        if(previousId && previousId !== _.get(child, referenceField)){\n          parentCollection.update({_id:previousId}, {$pull:{[cacheField]:{_id:child._id}}})\n        }\n        parentCollection.find({_id:_.get(child, referenceField)}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({_id:_.get(child, referenceField)}, {$pull:{[cacheField]:{_id:child._id}}})\n    })\n  }\n\n  else if(type == 'many-inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){        \n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({_id:{$in:references}}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let references = getNestedReferences(child)\n        let previousIds = this.previous && getNestedReferences(this.previous)\n        previousIds = _.difference(previousIds, references)\n        if(previousIds.length){\n          parentCollection.update({_id:{$in:previousIds}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n        }\n        if(references.length){\n          let pickedChild = _.pick(child, childFields)\n          parentCollection.find({_id:{$in:references}}, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n            if(index > -1){\n              parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n            } else {\n              parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n            }\n          })\n        }\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){\n        parentCollection.update({_id:{$in:references}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n      }\n    })\n  }\n}"]},"sourceType":"script","hash":"cff3f88c60f71612ed8b6cbe9527bc148764e274"}
