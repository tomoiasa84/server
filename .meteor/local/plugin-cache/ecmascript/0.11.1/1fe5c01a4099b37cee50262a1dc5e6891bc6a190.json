{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/exposure/exposure.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/cultofcoders:grapher/lib/exposure/exposure.js","filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/exposure/exposure.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/exposure/exposure.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:grapher/lib/exposure/exposure.js"}},"code":"module.export({\n  default: () => Exposure\n});\nlet genCountEndpoint;\nmodule.watch(require(\"../query/counts/genEndpoint.server.js\"), {\n  default(v) {\n    genCountEndpoint = v;\n  }\n\n}, 0);\nlet createGraph;\nmodule.watch(require(\"../query/lib/createGraph.js\"), {\n  default(v) {\n    createGraph = v;\n  }\n\n}, 1);\nlet recursiveCompose;\nmodule.watch(require(\"../query/lib/recursiveCompose.js\"), {\n  default(v) {\n    recursiveCompose = v;\n  }\n\n}, 2);\nlet hypernova;\nmodule.watch(require(\"../query/hypernova/hypernova.js\"), {\n  default(v) {\n    hypernova = v;\n  }\n\n}, 3);\nlet ExposureSchema, ExposureDefaults, validateBody;\nmodule.watch(require(\"./exposure.config.schema.js\"), {\n  ExposureSchema(v) {\n    ExposureSchema = v;\n  },\n\n  ExposureDefaults(v) {\n    ExposureDefaults = v;\n  },\n\n  validateBody(v) {\n    validateBody = v;\n  }\n\n}, 4);\nlet enforceMaxDepth;\nmodule.watch(require(\"./lib/enforceMaxDepth.js\"), {\n  default(v) {\n    enforceMaxDepth = v;\n  }\n\n}, 5);\nlet enforceMaxLimit;\nmodule.watch(require(\"./lib/enforceMaxLimit.js\"), {\n  default(v) {\n    enforceMaxLimit = v;\n  }\n\n}, 6);\nlet cleanBody;\nmodule.watch(require(\"./lib/cleanBody.js\"), {\n  default(v) {\n    cleanBody = v;\n  }\n\n}, 7);\nlet deepClone;\nmodule.watch(require(\"lodash.clonedeep\"), {\n  default(v) {\n    deepClone = v;\n  }\n\n}, 8);\nlet restrictFieldsFn;\nmodule.watch(require(\"./lib/restrictFields.js\"), {\n  default(v) {\n    restrictFieldsFn = v;\n  }\n\n}, 9);\nlet restrictLinks;\nmodule.watch(require(\"./lib/restrictLinks.js\"), {\n  default(v) {\n    restrictLinks = v;\n  }\n\n}, 10);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 11);\nlet globalConfig = {};\n\nclass Exposure {\n  static setConfig(config) {\n    Object.assign(globalConfig, config);\n  }\n\n  static getConfig() {\n    return globalConfig;\n  }\n\n  static restrictFields() {\n    return restrictFieldsFn(...arguments);\n  }\n\n  constructor(collection) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    collection.__isExposedForGrapher = true;\n    collection.__exposure = this;\n    this.collection = collection;\n    this.name = \"exposure_\".concat(collection._name);\n    this.config = config;\n\n    this._validateAndClean();\n\n    this.initSecurity();\n\n    if (this.config.publication) {\n      this.initPublication();\n    }\n\n    if (this.config.method) {\n      this.initMethod();\n    }\n\n    if (!this.config.method && !this.config.publication) {\n      throw new Meteor.Error('weird', 'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true');\n    }\n\n    this.initCountMethod();\n    this.initCountPublication();\n  }\n\n  _validateAndClean() {\n    if (typeof this.config === 'function') {\n      const firewall = this.config;\n      this.config = {\n        firewall\n      };\n    }\n\n    this.config = Object.assign({}, ExposureDefaults, Exposure.getConfig(), this.config);\n    check(this.config, ExposureSchema);\n\n    if (this.config.body) {\n      validateBody(this.collection, this.config.body);\n    }\n  }\n  /**\n   * Takes the body and intersects it with the exposure body, if it exists.\n   *\n   * @param body\n   * @param userId\n   * @returns {*}\n   */\n\n\n  getTransformedBody(body, userId) {\n    if (!this.config.body) {\n      return body;\n    }\n\n    const processedBody = this.getBody(userId);\n\n    if (processedBody === true) {\n      return;\n    }\n\n    return cleanBody(processedBody, body);\n  }\n  /**\n   * Gets the exposure body\n   */\n\n\n  getBody(userId) {\n    if (!this.config.body) {\n      throw new Meteor.Error('missing-body', 'Cannot get exposure body because it was not defined.');\n    }\n\n    let body;\n\n    if (_.isFunction(this.config.body)) {\n      body = this.config.body.call(this, userId);\n    } else {\n      body = this.config.body;\n    } // it means we allow everything, no need for cloning.\n\n\n    if (body === true) {\n      return true;\n    }\n\n    return deepClone(body, userId);\n  }\n  /**\n   * Initializing the publication for reactive query fetching\n   */\n\n\n  initPublication() {\n    const collection = this.collection;\n    const config = this.config;\n    const getTransformedBody = this.getTransformedBody.bind(this);\n    Meteor.publishComposite(this.name, function (body) {\n      let transformedBody = getTransformedBody(body);\n      const rootNode = createGraph(collection, transformedBody);\n      enforceMaxDepth(rootNode, config.maxDepth);\n      restrictLinks(rootNode, this.userId);\n      return recursiveCompose(rootNode, this.userId, {\n        bypassFirewalls: !!config.body\n      });\n    });\n  }\n  /**\n   * Initializez the method to retrieve the data via Meteor.call\n   */\n\n\n  initMethod() {\n    const collection = this.collection;\n    const config = this.config;\n    const getTransformedBody = this.getTransformedBody.bind(this);\n\n    const methodBody = function (body) {\n      if (!config.blocking) {\n        this.unblock();\n      }\n\n      let transformedBody = getTransformedBody(body);\n      const rootNode = createGraph(collection, transformedBody);\n      enforceMaxDepth(rootNode, config.maxDepth);\n      restrictLinks(rootNode, this.userId); // if there is no exposure body defined, then we need to apply firewalls\n\n      return hypernova(rootNode, this.userId, {\n        bypassFirewalls: !!config.body\n      });\n    };\n\n    Meteor.methods({\n      [this.name]: methodBody\n    });\n  }\n  /**\n   * Initializes the method to retrieve the count of the data via Meteor.call\n   * @returns {*}\n   */\n\n\n  initCountMethod() {\n    const collection = this.collection;\n    Meteor.methods({\n      [this.name + '.count'](body) {\n        this.unblock();\n        return collection.find(body.$filters || {}, {}, this.userId).count();\n      }\n\n    });\n  }\n  /**\n   * Initializes the reactive endpoint to retrieve the count of the data.\n   */\n\n\n  initCountPublication() {\n    const collection = this.collection;\n    genCountEndpoint(this.name, {\n      getCursor(_ref) {\n        let {\n          session\n        } = _ref;\n        return collection.find(session.filters, {\n          fields: {\n            _id: 1\n          }\n        }, this.userId);\n      },\n\n      getSession(body) {\n        return {\n          filters: body.$filters || {}\n        };\n      }\n\n    });\n  }\n  /**\n   * Initializes security enforcement\n   * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n   */\n\n\n  initSecurity() {\n    const collection = this.collection;\n    const {\n      firewall,\n      maxLimit,\n      restrictedFields\n    } = this.config;\n    const find = collection.find.bind(collection);\n    const findOne = collection.findOne.bind(collection);\n\n    collection.firewall = (filters, options, userId) => {\n      if (userId !== undefined) {\n        this._callFirewall({\n          collection: collection\n        }, filters, options, userId);\n\n        enforceMaxLimit(options, maxLimit);\n\n        if (restrictedFields) {\n          Exposure.restrictFields(filters, options, restrictedFields);\n        }\n      }\n    };\n\n    collection.find = function (filters) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let userId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (arguments.length == 0) {\n        filters = {};\n      } // If filters is undefined it should return an empty item\n\n\n      if (arguments.length > 0 && filters === undefined) {\n        return find(undefined, options);\n      }\n\n      collection.firewall(filters, options, userId);\n      return find(filters, options);\n    };\n\n    collection.findOne = function (filters) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let userId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      // If filters is undefined it should return an empty item\n      if (arguments.length > 0 && filters === undefined) {\n        return null;\n      }\n\n      if (typeof filters === 'string') {\n        filters = {\n          _id: filters\n        };\n      }\n\n      collection.firewall(filters, options, userId);\n      return findOne(filters, options);\n    };\n  }\n  /**\n   * @private\n   */\n\n\n  _callFirewall() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const {\n      firewall\n    } = this.config;\n\n    if (!firewall) {\n      return;\n    }\n\n    if (_.isArray(firewall)) {\n      firewall.forEach(fire => {\n        fire.call(...args);\n      });\n    } else {\n      firewall.call(...args);\n    }\n  }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/exposure.js"],"names":["module","export","default","Exposure","genCountEndpoint","watch","require","v","createGraph","recursiveCompose","hypernova","ExposureSchema","ExposureDefaults","validateBody","enforceMaxDepth","enforceMaxLimit","cleanBody","deepClone","restrictFieldsFn","restrictLinks","check","globalConfig","setConfig","config","Object","assign","getConfig","restrictFields","constructor","collection","__isExposedForGrapher","__exposure","name","_name","_validateAndClean","initSecurity","publication","initPublication","method","initMethod","Meteor","Error","initCountMethod","initCountPublication","firewall","body","getTransformedBody","userId","processedBody","getBody","_","isFunction","call","bind","publishComposite","transformedBody","rootNode","maxDepth","bypassFirewalls","methodBody","blocking","unblock","methods","find","$filters","count","getCursor","session","filters","fields","_id","getSession","maxLimit","restrictedFields","findOne","options","undefined","_callFirewall","arguments","length","args","isArray","forEach","fire"],"mappings":"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","sourcesContent":["import genCountEndpoint from '../query/counts/genEndpoint.server.js';\nimport createGraph from '../query/lib/createGraph.js';\nimport recursiveCompose from '../query/lib/recursiveCompose.js';\nimport hypernova from '../query/hypernova/hypernova.js';\nimport {\n    ExposureSchema,\n    ExposureDefaults,\n    validateBody,\n} from './exposure.config.schema.js';\nimport enforceMaxDepth from './lib/enforceMaxDepth.js';\nimport enforceMaxLimit from './lib/enforceMaxLimit.js';\nimport cleanBody from './lib/cleanBody.js';\nimport deepClone from 'lodash.clonedeep';\nimport restrictFieldsFn from './lib/restrictFields.js';\nimport restrictLinks from './lib/restrictLinks.js';\nimport { check } from 'meteor/check';\n\nlet globalConfig = {};\n\nexport default class Exposure {\n    static setConfig(config) {\n        Object.assign(globalConfig, config);\n    }\n\n    static getConfig() {\n        return globalConfig;\n    }\n\n    static restrictFields(...args) {\n        return restrictFieldsFn(...args);\n    }\n\n    constructor(collection, config = {}) {\n        collection.__isExposedForGrapher = true;\n        collection.__exposure = this;\n\n        this.collection = collection;\n        this.name = `exposure_${collection._name}`;\n\n        this.config = config;\n        this._validateAndClean();\n\n        this.initSecurity();\n\n        if (this.config.publication) {\n            this.initPublication();\n        }\n\n        if (this.config.method) {\n            this.initMethod();\n        }\n\n        if (!this.config.method && !this.config.publication) {\n            throw new Meteor.Error(\n                'weird',\n                'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true'\n            );\n        }\n\n        this.initCountMethod();\n        this.initCountPublication();\n    }\n\n    _validateAndClean() {\n        if (typeof this.config === 'function') {\n            const firewall = this.config;\n            this.config = { firewall };\n        }\n\n        this.config = Object.assign(\n            {},\n            ExposureDefaults,\n            Exposure.getConfig(),\n            this.config\n        );\n        check(this.config, ExposureSchema);\n\n        if (this.config.body) {\n            validateBody(this.collection, this.config.body);\n        }\n    }\n\n    /**\n     * Takes the body and intersects it with the exposure body, if it exists.\n     *\n     * @param body\n     * @param userId\n     * @returns {*}\n     */\n    getTransformedBody(body, userId) {\n        if (!this.config.body) {\n            return body;\n        }\n\n        const processedBody = this.getBody(userId);\n\n        if (processedBody === true) {\n            return;\n        }\n\n        return cleanBody(processedBody, body);\n    }\n\n    /**\n     * Gets the exposure body\n     */\n    getBody(userId) {\n        if (!this.config.body) {\n            throw new Meteor.Error(\n                'missing-body',\n                'Cannot get exposure body because it was not defined.'\n            );\n        }\n\n        let body;\n        if (_.isFunction(this.config.body)) {\n            body = this.config.body.call(this, userId);\n        } else {\n            body = this.config.body;\n        }\n\n        // it means we allow everything, no need for cloning.\n        if (body === true) {\n            return true;\n        }\n\n        return deepClone(body, userId);\n    }\n\n    /**\n     * Initializing the publication for reactive query fetching\n     */\n    initPublication() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        Meteor.publishComposite(this.name, function(body) {\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            return recursiveCompose(rootNode, this.userId, {\n                bypassFirewalls: !!config.body,\n            });\n        });\n    }\n\n    /**\n     * Initializez the method to retrieve the data via Meteor.call\n     */\n    initMethod() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        const methodBody = function(body) {\n            if (!config.blocking) {\n                this.unblock();\n            }\n\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            // if there is no exposure body defined, then we need to apply firewalls\n            return hypernova(rootNode, this.userId, {\n                bypassFirewalls: !!config.body,\n            });\n        };\n\n        Meteor.methods({\n            [this.name]: methodBody,\n        });\n    }\n\n    /**\n     * Initializes the method to retrieve the count of the data via Meteor.call\n     * @returns {*}\n     */\n    initCountMethod() {\n        const collection = this.collection;\n\n        Meteor.methods({\n            [this.name + '.count'](body) {\n                this.unblock();\n\n                return collection\n                    .find(body.$filters || {}, {}, this.userId)\n                    .count();\n            },\n        });\n    }\n\n    /**\n     * Initializes the reactive endpoint to retrieve the count of the data.\n     */\n    initCountPublication() {\n        const collection = this.collection;\n\n        genCountEndpoint(this.name, {\n            getCursor({ session }) {\n                return collection.find(\n                    session.filters,\n                    {\n                        fields: { _id: 1 },\n                    },\n                    this.userId\n                );\n            },\n\n            getSession(body) {\n                return { filters: body.$filters || {} };\n            },\n        });\n    }\n\n    /**\n     * Initializes security enforcement\n     * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n     */\n    initSecurity() {\n        const collection = this.collection;\n        const { firewall, maxLimit, restrictedFields } = this.config;\n        const find = collection.find.bind(collection);\n        const findOne = collection.findOne.bind(collection);\n\n        collection.firewall = (filters, options, userId) => {\n            if (userId !== undefined) {\n                this._callFirewall(\n                    { collection: collection },\n                    filters,\n                    options,\n                    userId\n                );\n\n                enforceMaxLimit(options, maxLimit);\n\n                if (restrictedFields) {\n                    Exposure.restrictFields(filters, options, restrictedFields);\n                }\n            }\n        };\n\n        collection.find = function(filters, options = {}, userId = undefined) {\n            if (arguments.length == 0) {\n                filters = {};\n            }\n\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return find(undefined, options);\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return find(filters, options);\n        };\n\n        collection.findOne = function(\n            filters,\n            options = {},\n            userId = undefined\n        ) {\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return null;\n            }\n\n            if (typeof filters === 'string') {\n                filters = { _id: filters };\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return findOne(filters, options);\n        };\n    }\n\n    /**\n     * @private\n     */\n    _callFirewall(...args) {\n        const { firewall } = this.config;\n        if (!firewall) {\n            return;\n        }\n\n        if (_.isArray(firewall)) {\n            firewall.forEach(fire => {\n                fire.call(...args);\n            });\n        } else {\n            firewall.call(...args);\n        }\n    }\n}\n"]},"sourceType":"script","hash":"1fe5c01a4099b37cee50262a1dc5e6891bc6a190"}
