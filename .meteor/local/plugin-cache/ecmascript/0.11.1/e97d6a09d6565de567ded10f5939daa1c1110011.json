{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"}},"code":"module.export({\n  applyPostFilters: () => applyPostFilters,\n  applyPostOptions: () => applyPostOptions,\n  getResultsArray: () => getResultsArray,\n  removeLinkStorages: () => removeLinkStorages,\n  storeOneResults: () => storeOneResults,\n  assembleMetadata: () => assembleMetadata\n});\nlet applyReducers;\nmodule.watch(require(\"../reducers/lib/applyReducers\"), {\n  default(v) {\n    applyReducers = v;\n  }\n\n}, 0);\nlet cleanReducerLeftovers;\nmodule.watch(require(\"../reducers/lib/cleanReducerLeftovers\"), {\n  default(v) {\n    cleanReducerLeftovers = v;\n  }\n\n}, 1);\nlet sift;\nmodule.watch(require(\"sift\"), {\n  default(v) {\n    sift = v;\n  }\n\n}, 2);\nlet Minimongo;\nmodule.watch(require(\"meteor/minimongo\"), {\n  Minimongo(v) {\n    Minimongo = v;\n  }\n\n}, 3);\nmodule.exportDefault((node, params) => {\n  snapBackCaches(node);\n  storeOneResults(node, node.results);\n  applyReducers(node, params);\n  cleanReducerLeftovers(node);\n\n  _.each(node.collectionNodes, collectionNode => {\n    cloneMetaChildren(collectionNode, node.results);\n  });\n\n  _.each(node.collectionNodes, collectionNode => {\n    assembleMetadata(collectionNode, node.results);\n  });\n\n  removeLinkStorages(node, node.results);\n  applyPostFilters(node);\n  applyPostOptions(node);\n  applyPostFilter(node, params);\n});\n\nfunction applyPostFilters(node) {\n  const postFilters = node.props.$postFilters;\n\n  if (postFilters) {\n    node.results = sift(postFilters, node.results);\n  }\n}\n\nfunction applyPostOptions(node) {\n  const options = node.props.$postOptions;\n\n  if (options) {\n    if (options.sort) {\n      const sorter = new Minimongo.Sorter(options.sort);\n      node.results.sort(sorter.getComparator());\n    }\n\n    if (options.limit || options.skip) {\n      const start = options.skip || 0;\n      const end = options.limit ? options.limit + start : node.results.length;\n      node.results = node.results.slice(start, end);\n    }\n  }\n}\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n  if (node.props.$postFilter) {\n    const filter = node.props.$postFilter;\n\n    if (_.isArray(filter)) {\n      filter.forEach(f => {\n        node.results = f(node.results, params);\n      });\n    } else {\n      node.results = filter(node.results, params);\n    }\n  }\n}\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\n\n\nfunction getResultsArray(results) {\n  if (_.isArray(results)) {\n    return results;\n  } else if (_.isUndefined(results)) {\n    return [];\n  }\n\n  return [results];\n}\n\nfunction removeLinkStorages(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  sameLevelResults = getResultsArray(sameLevelResults);\n\n  _.each(node.collectionNodes, collectionNode => {\n    const removeStorageField = collectionNode.shouldCleanStorage;\n\n    _.each(sameLevelResults, result => {\n      if (removeStorageField) {\n        delete result[collectionNode.linkStorageField];\n      }\n\n      removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n    });\n  });\n}\n\nfunction storeOneResults(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(sameLevelResults, result => {\n      storeOneResults(collectionNode, result[collectionNode.linkName]);\n    });\n\n    if (collectionNode.isOneResult) {\n      _.each(sameLevelResults, result => {\n        if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n          result[collectionNode.linkName] = result[collectionNode.linkName] ? _.first(result[collectionNode.linkName]) : undefined;\n        }\n      });\n    }\n  });\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n  if (!parentResults) {\n    return;\n  }\n\n  const linkName = node.linkName;\n  const isMeta = node.isMeta; // parentResults might be an object (for type==one links)\n\n  parentResults = getResultsArray(parentResults);\n  parentResults.forEach(parentResult => {\n    if (isMeta && parentResult[linkName]) {\n      if (node.isOneResult) {\n        parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n      } else {\n        parentResult[linkName] = parentResult[linkName].map(object => {\n          return Object.assign({}, object);\n        });\n      }\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n      cloneMetaChildren(collectionNode, parentResult[linkName]);\n    });\n  });\n}\n\nfunction assembleMetadata(node, parentResults) {\n  parentResults = getResultsArray(parentResults); // assembling metadata is depth first\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(parentResults, result => {\n      assembleMetadata(collectionNode, result[node.linkName]);\n    });\n  });\n\n  if (node.isMeta) {\n    if (node.isVirtual) {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n\n        if (node.isOneResult) {\n          const storage = childResult[node.linkStorageField];\n          storeMetadata(childResult, parentResult, storage, true);\n        } else {\n          _.each(childResult, object => {\n            const storage = object[node.linkStorageField];\n            storeMetadata(object, parentResult, storage, true);\n          });\n        }\n      });\n    } else {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n        const storage = parentResult[node.linkStorageField];\n\n        if (node.isOneResult) {\n          if (childResult) {\n            storeMetadata(childResult, parentResult, storage, false);\n          }\n        } else {\n          _.each(childResult, object => {\n            storeMetadata(object, parentResult, storage, false);\n          });\n        }\n      });\n    }\n  }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n  if (isVirtual) {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  } else {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  }\n}\n\nfunction snapBackCaches(node) {\n  node.collectionNodes.forEach(collectionNode => {\n    snapBackCaches(collectionNode);\n  });\n\n  if (!_.isEmpty(node.snapCaches)) {\n    // process stuff\n    _.each(node.snapCaches, (linkName, cacheField) => {\n      const isSingle = _.contains(node.snapCachesSingles, cacheField);\n\n      const linker = node.collection.getLinker(linkName); // we do this because for one direct and one meta direct, id is not stored\n\n      const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n      node.results.forEach(result => {\n        if (result[cacheField]) {\n          if (shoudStoreLinkStorage) {\n            Object.assign(result[cacheField], {\n              _id: linker.isMeta() ? result[linker.linkStorageField]._id : result[linker.linkStorageField]\n            });\n          }\n\n          if (isSingle && _.isArray(result[cacheField])) {\n            result[linkName] = _.first(result[cacheField]);\n          } else {\n            result[linkName] = result[cacheField];\n          }\n\n          delete result[cacheField];\n        }\n      });\n    });\n  }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"],"names":["module","export","applyPostFilters","applyPostOptions","getResultsArray","removeLinkStorages","storeOneResults","assembleMetadata","applyReducers","watch","require","default","v","cleanReducerLeftovers","sift","Minimongo","exportDefault","node","params","snapBackCaches","results","_","each","collectionNodes","collectionNode","cloneMetaChildren","applyPostFilter","postFilters","props","$postFilters","options","$postOptions","sort","sorter","Sorter","getComparator","limit","skip","start","end","length","slice","$postFilter","filter","isArray","forEach","f","isUndefined","sameLevelResults","removeStorageField","shouldCleanStorage","result","linkStorageField","linkName","isOneResult","first","undefined","parentResults","isMeta","parentResult","Object","assign","map","object","isVirtual","childResult","storage","storeMetadata","element","parentElement","$metadata","find","storageItem","_id","omit","isEmpty","snapCaches","cacheField","isSingle","contains","snapCachesSingles","linker","collection","getLinker","shoudStoreLinkStorage","isMany"],"mappings":"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","sourcesContent":["// 1. Clone children with meta relationships\n// 2. Apply $metadata to children\n// 3. Removes link storage (if not specified)\n// 4. Stores oneResult links as a single object instead of array\nimport applyReducers from '../reducers/lib/applyReducers';\nimport cleanReducerLeftovers from '../reducers/lib/cleanReducerLeftovers';\nimport sift from 'sift';\nimport {Minimongo} from 'meteor/minimongo';\n\nexport default (node, params) => {\n    snapBackCaches(node);\n    storeOneResults(node, node.results);\n    applyReducers(node, params);\n    cleanReducerLeftovers(node);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results)\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results)\n    });\n\n    removeLinkStorages(node, node.results);\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n}\n\nexport function applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nexport function applyPostOptions(node) {\n    const options = node.props.$postOptions;\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            })\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\nexport function getResultsArray(results) {\n    if (_.isArray(results)) {\n        return results;\n    }\n    else if (_.isUndefined(results)) {\n        return [];\n    }\n    return [results];\n}\n\nexport function removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    sameLevelResults = getResultsArray(sameLevelResults);\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                delete result[collectionNode.linkStorageField];\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        })\n    })\n}\n\nexport function storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            _.each(sameLevelResults, result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName]\n                        ? _.first(result[collectionNode.linkName])\n                        : undefined;\n                }\n            })\n        }\n    })\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n\n    // parentResults might be an object (for type==one links)\n    parentResults = getResultsArray(parentResults);\n\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            if (node.isOneResult) {\n                parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n            }\n            else {\n                parentResult[linkName] = parentResult[linkName].map(object => {\n                    return Object.assign({}, object);\n                });\n            }\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nexport function assembleMetadata(node, parentResults) {\n    parentResults = getResultsArray(parentResults);\n\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName])\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                if (node.isOneResult) {\n                    const storage = childResult[node.linkStorageField];\n                    storeMetadata(childResult, parentResult, storage, true);\n                } else {\n                    _.each(childResult, object => {\n                        const storage = object[node.linkStorageField];\n\n                        storeMetadata(object, parentResult, storage, true);\n                    });\n                }\n            })\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                if (node.isOneResult) {\n                    if (childResult) {\n                        storeMetadata(childResult, parentResult, storage, false);\n                    }\n                } else {\n                    _.each(childResult, object => {\n                        storeMetadata(object, parentResult, storage, false);\n                    });\n                }\n            })\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id')\n    } else {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n            const linker = node.collection.getLinker(linkName);\n            // we do this because for one direct and one meta direct, id is not stored\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta()\n                                ? result[linker.linkStorageField]._id\n                                : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            })\n        })\n    }\n}\n"]},"sourceType":"script","hash":"e97d6a09d6565de567ded10f5939daa1c1110011"}
