{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/herteby:denormalize/cache.js","filename":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/herteby:denormalize/cache.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/herteby:denormalize/cache.js"}},"code":"module.export({\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.link(\"lodash\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration, migrate, autoMigrate;\nmodule.link(\"./migrations.js\", {\n  addMigration(v) {\n    addMigration = v;\n  },\n\n  migrate(v) {\n    migrate = v;\n  },\n\n  autoMigrate(v) {\n    autoMigrate = v;\n  }\n\n}, 1);\n\nfunction flattenFields(object, prefix) {\n  prefix = prefix || '';\n  let fields = [];\n\n  _.each(object, (val, key) => {\n    if (typeof val == 'object') {\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'));\n    } else {\n      fields.push(prefix + key);\n    }\n  });\n\n  return fields;\n}\n\nMongo.Collection.prototype.cache = function (options) {\n  check(options, {\n    collection: Match.Where(collection => collection instanceof Mongo.Collection),\n    fields: Match.OneOf([String], Object),\n    type: Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField: String,\n    cacheField: String,\n    bypassSchema: Match.Optional(Boolean)\n  });\n  if (options.type == 'inverse') options.type = 'inversed'; //Not sure which is best, so why not support both and be typo-friendly\n\n  if (options.type == 'many-inverse') options.type = 'many-inversed'; //Bypass collection2 schemas\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let type = options.type;\n  let referenceField = options.referenceField;\n  let cacheField = options.cacheField;\n  let watchedFields = options.fields;\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  if (!_.isArray(watchedFields)) {\n    watchedFields = flattenFields(watchedFields);\n  }\n\n  let childFields = _.clone(watchedFields);\n\n  if (type !== 'one') {\n    if (!_.includes(childFields, '_id')) {\n      childFields.push('_id');\n    }\n\n    _.pull(childFields, referenceField);\n  }\n\n  let childOpts = {\n    transform: null,\n    fields: {\n      _id: 0\n    }\n  };\n\n  _.each(childFields, field => childOpts.fields[field] = 1);\n\n  let parentOpts = {\n    transform: null,\n    fields: {\n      _id: 1,\n      [cacheField]: 1\n    }\n  };\n\n  if (type !== 'inversed' && type !== 'many-inversed') {\n    parentOpts.fields[referenceField.split(':')[0]] = 1;\n  }\n\n  let idField, referencePath;\n\n  if (type == 'many' || type == 'many-inversed') {\n    referencePath = referenceField.replace(':', '.');\n    idField = referenceField.split(':')[1];\n    referenceField = referenceField.split(':')[0];\n  }\n\n  if (type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)) {\n    watchedFields.push(referencePath || referenceField);\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]));\n\n  function getNestedReferences(document) {\n    //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || [];\n\n    if (idField && references.length) {\n      references = _.map(references, item => _.get(item, idField));\n    }\n\n    return _.uniq(_.flatten(references));\n  }\n\n  if (type == 'one') {\n    let insert = function insert(userId, parent) {\n      if (_.get(parent, referenceField)) {\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        }\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $unset: {\n              [cacheField]: 1\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $set: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          [referenceField]: child._id\n        }, {\n          $set: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $unset: {\n          [cacheField]: 1\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'many') {\n    let insert = function insert(userId, parent) {\n      let references = getNestedReferences(parent);\n\n      if (references.length) {\n        let children = childCollection.find({\n          _id: {\n            $in: references\n          }\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      } else {\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: []\n          }\n        });\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let references = getNestedReferences(parent);\n\n        if (references.length) {\n          let children = childCollection.find({\n            _id: {\n              $in: references\n            }\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $push: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.find({\n          [referencePath]: child._id\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referenceField]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        if (_.get(parent, referenceField)) {\n          let children = childCollection.find({\n            [referenceField]: parent._id\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      if (_.get(child, referenceField)) {\n        parentCollection.update({\n          _id: _.get(child, referenceField)\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        let previousId = this.previous && _.get(this.previous, referenceField);\n\n        if (previousId && previousId !== _.get(child, referenceField)) {\n          parentCollection.update({\n            _id: previousId\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          });\n        }\n\n        parentCollection.find({\n          _id: _.get(child, referenceField)\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        _id: _.get(child, referenceField)\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      });\n    });\n  } else if (type == 'many-inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referencePath]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let children = childCollection.find({\n          [referencePath]: parent._id\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let references = getNestedReferences(child);\n        let previousIds = this.previous && getNestedReferences(this.previous);\n        previousIds = _.difference(previousIds, references);\n\n        if (previousIds.length) {\n          parentCollection.update({\n            _id: {\n              $in: previousIds\n            }\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          }, {\n            multi: true\n          });\n        }\n\n        if (references.length) {\n          let pickedChild = _.pick(child, childFields);\n\n          parentCollection.find({\n            _id: {\n              $in: references\n            }\n          }, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {\n              _id: child._id\n            });\n\n            if (index > -1) {\n              parentCollection.update(parent._id, {\n                $set: {\n                  [cacheField + '.' + index]: pickedChild\n                }\n              });\n            } else {\n              parentCollection.update(parent._id, {\n                $push: {\n                  [cacheField]: pickedChild\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $pull: {\n            [cacheField]: {\n              _id: child._id\n            }\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n  }\n};","map":{"version":3,"sources":["packages/herteby:denormalize/cache.js"],"names":["module","export","migrate","autoMigrate","_","link","default","v","addMigration","flattenFields","object","prefix","fields","each","val","key","union","push","Mongo","Collection","prototype","cache","options","check","collection","Match","Where","OneOf","String","Object","type","referenceField","cacheField","bypassSchema","Optional","Boolean","parentCollection","Package","_collection","childCollection","watchedFields","split","Error","isArray","childFields","clone","includes","pull","childOpts","transform","_id","field","parentOpts","idField","referencePath","replace","topFields","uniq","map","getNestedReferences","document","references","get","length","item","flatten","insert","userId","parent","child","findOne","update","$set","after","changedFields","$unset","pickedChild","pick","multi","intersection","remove","children","find","$in","fetch","$push","forEach","index","findIndex","$pull","previousId","previous","previousIds","difference"],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport {addMigration, migrate, autoMigrate} from './migrations.js'\n\nexport {migrate, autoMigrate}\n\nfunction flattenFields(object, prefix){\n  prefix = prefix || ''\n  let fields = []\n  _.each(object, (val, key) => {\n    if(typeof val == 'object'){\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'))\n    } else {\n      fields.push(prefix + key)\n    }\n  })\n  return fields\n}\n\nMongo.Collection.prototype.cache = function(options){\n  check(options, {\n    collection:Match.Where(collection => collection instanceof Mongo.Collection),\n    fields:Match.OneOf([String], Object),\n    type:Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField:String,\n    cacheField:String,\n    bypassSchema:Match.Optional(Boolean)\n  })\n  if(options.type == 'inverse') options.type = 'inversed' //Not sure which is best, so why not support both and be typo-friendly\n  if(options.type == 'many-inverse') options.type = 'many-inversed'\n\n  //Bypass collection2 schemas\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let type = options.type\n  let referenceField = options.referenceField\n  let cacheField = options.cacheField\n  let watchedFields = options.fields\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  if(!_.isArray(watchedFields)){\n    watchedFields = flattenFields(watchedFields)\n  }\n\n  let childFields = _.clone(watchedFields)\n  if(type !== 'one'){\n    if(!_.includes(childFields, '_id')){\n      childFields.push('_id')\n    }\n    _.pull(childFields, referenceField)\n  }\n  let childOpts = {transform:null, fields:{_id:0}}\n  _.each(childFields, field => childOpts.fields[field] = 1)\n\n  let parentOpts = {transform:null, fields:{_id:1, [cacheField]:1}}\n  if(type !== 'inversed' && type !== 'many-inversed'){\n    parentOpts.fields[referenceField.split(':')[0]] = 1\n  }\n\n  let idField, referencePath\n  if(type == 'many' || type == 'many-inversed'){\n    referencePath = referenceField.replace(':', '.')\n    idField = referenceField.split(':')[1]\n    referenceField = referenceField.split(':')[0]\n  }\n\n  if(type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)){\n    watchedFields.push(referencePath || referenceField)\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]))\n\n  function getNestedReferences(document){ //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || []\n    if(idField && references.length){\n      references = _.map(references, item => _.get(item, idField))\n    }\n    return _.uniq(_.flatten(references))\n  }\n\n\n  if(type == 'one'){\n    let insert = function insert(userId, parent){\n      if(_.get(parent, referenceField)){\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        }\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        } else {\n          parentCollection.update(parent._id, {$unset:{[cacheField]:1}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referenceField]:child._id}, {$unset:{[cacheField]:1}}, {multi:true})\n    })\n  } \n\n  else if(type == 'many'){\n    let insert = function insert(userId, parent){\n      let references = getNestedReferences(parent)\n      if(references.length){\n        let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      } else {\n        parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let references = getNestedReferences(parent)\n        if(references.length){\n          let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referencePath]:child._id}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.find({[referencePath]:child._id}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referencePath]:child._id}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n    })\n  }\n\n\n  else if(type == 'inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        if(_.get(parent, referenceField)){\n          let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      if(_.get(child, referenceField)){\n        parentCollection.update({_id:_.get(child, referenceField)}, {$push:{[cacheField]:pickedChild}})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        let previousId = this.previous && _.get(this.previous, referenceField)\n        if(previousId && previousId !== _.get(child, referenceField)){\n          parentCollection.update({_id:previousId}, {$pull:{[cacheField]:{_id:child._id}}})\n        }\n        parentCollection.find({_id:_.get(child, referenceField)}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({_id:_.get(child, referenceField)}, {$pull:{[cacheField]:{_id:child._id}}})\n    })\n  }\n\n  else if(type == 'many-inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){        \n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({_id:{$in:references}}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let references = getNestedReferences(child)\n        let previousIds = this.previous && getNestedReferences(this.previous)\n        previousIds = _.difference(previousIds, references)\n        if(previousIds.length){\n          parentCollection.update({_id:{$in:previousIds}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n        }\n        if(references.length){\n          let pickedChild = _.pick(child, childFields)\n          parentCollection.find({_id:{$in:references}}, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n            if(index > -1){\n              parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n            } else {\n              parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n            }\n          })\n        }\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){\n        parentCollection.update({_id:{$in:references}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n      }\n    })\n  }\n}"]},"sourceType":"script","hash":"12e1d903415bc900568f2bdb78e3c2689a19c2f7"}
