{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js","filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js"}},"code":"module.export({\n  default: () => addReducers,\n  handleAddElement: () => handleAddElement,\n  handleAddReducer: () => handleAddReducer,\n  handleAddLink: () => handleAddLink,\n  handleAddField: () => handleAddField\n});\nlet dot;\nmodule.link(\"dot-object\", {\n  default(v) {\n    dot = v;\n  }\n\n}, 0);\nlet createNodes;\nmodule.link(\"../../lib/createGraph\", {\n  createNodes(v) {\n    createNodes = v;\n  }\n\n}, 1);\nlet CollectionNode;\nmodule.link(\"../../nodes/collectionNode\", {\n  default(v) {\n    CollectionNode = v;\n  }\n\n}, 2);\nlet FieldNode;\nmodule.link(\"../../nodes/fieldNode\", {\n  default(v) {\n    FieldNode = v;\n  }\n\n}, 3);\nlet ReducerNode;\nmodule.link(\"../../nodes/reducerNode\", {\n  default(v) {\n    ReducerNode = v;\n  }\n\n}, 4);\nlet embedReducerWithLink;\nmodule.link(\"./embedReducerWithLink\", {\n  default(v) {\n    embedReducerWithLink = v;\n  }\n\n}, 5);\nlet specialFields;\nmodule.link(\"../../lib/createGraph\", {\n  specialFields(v) {\n    specialFields = v;\n  }\n\n}, 6);\n\nfunction addReducers(root) {\n  // we add reducers last, after we have added all the fields.\n  root.reducerNodes.forEach(reducer => {\n    _.each(reducer.body, (body, fieldName) => {\n      handleAddElement(reducer, root, fieldName, body);\n    });\n  });\n}\n\nfunction handleAddElement(reducerNode, root, fieldName, body) {\n  // if it's a link\n  const collection = root.collection;\n  const linker = collection.getLinker(fieldName);\n\n  if (linker) {\n    return handleAddLink(reducerNode, fieldName, body, root, linker);\n  }\n\n  const reducer = collection.getReducer(fieldName);\n\n  if (reducer) {\n    reducerNode.dependencies.push(fieldName);\n    return handleAddReducer(fieldName, reducer, root);\n  } // we assume it's a field in this case\n\n\n  return handleAddField(fieldName, body, root);\n}\n\nfunction handleAddReducer(fieldName, {\n  body,\n  reduce\n}, root) {\n  if (!root.hasReducerNode(fieldName)) {\n    let childReducerNode = new ReducerNode(fieldName, {\n      body,\n      reduce\n    });\n    root.add(childReducerNode);\n    childReducerNode.scheduledForDeletion = true;\n\n    _.each(childReducerNode.body, (body, fieldName) => {\n      handleAddElement(childReducerNode, root, fieldName, body);\n    });\n  }\n}\n\nfunction handleAddLink(reducerNode, fieldName, body, parent, linker) {\n  if (parent.hasCollectionNode(fieldName)) {\n    const collectionNode = parent.getCollectionNode(fieldName);\n    embedReducerWithLink(reducerNode, body, collectionNode);\n  } else {\n    // add\n    let collectionNode = new CollectionNode(linker.getLinkedCollection(), body, fieldName);\n    collectionNode.scheduledForDeletion = true;\n    parent.add(collectionNode, linker);\n    createNodes(collectionNode);\n  }\n}\n\nfunction handleAddField(fieldName, body, root) {\n  if (_.contains(specialFields, fieldName)) {\n    root.addProp(fieldName, body);\n    return;\n  }\n\n  if (_.isObject(body)) {\n    // if reducer specifies a nested field\n    // if it's a prop\n    const dots = dot.dot({\n      [fieldName]: body\n    });\n\n    _.each(dots, (value, key) => {\n      addFieldIfRequired(root, key, value);\n    });\n  } else {\n    // if reducer does not specify a nested field, and the field does not exist.\n    addFieldIfRequired(root, fieldName, body);\n  }\n}\n\nfunction addFieldIfRequired(root, fieldName, body) {\n  if (!root.hasField(fieldName, true)) {\n    /**\n     * Check if there are any nested fields for this field.\n     * Adding root field here and scheduling for deletion would not work if there is already nested field, \n     * for example:\n     * when trying to add meta: 1, it should be checked that there are no meta.* fields\n     * */\n    const nestedFields = root.fieldNodes.filter(({\n      name\n    }) => name.startsWith(`${fieldName}.`)); // remove nested fields - important for minimongo which complains for these situations\n    // TODO: excess fields are not removed (caused by adding the root field and removing nested fields) but there\n    // should probably be a way to handle this in post-processing - for example by keeping a whitelist of fields\n    // and removing anything else\n\n    nestedFields.forEach(node => root.remove(node));\n    let fieldNode = new FieldNode(fieldName, body); // delete only if all nested fields are scheduled for deletion (that includes the case of 0 nested fields)\n\n    fieldNode.scheduledForDeletion = nestedFields.every(field => field.scheduledForDeletion);\n    root.add(fieldNode);\n  }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/reducers/lib/createReducers.js"],"names":["module","export","default","addReducers","handleAddElement","handleAddReducer","handleAddLink","handleAddField","dot","link","v","createNodes","CollectionNode","FieldNode","ReducerNode","embedReducerWithLink","specialFields","root","reducerNodes","forEach","reducer","_","each","body","fieldName","reducerNode","collection","linker","getLinker","getReducer","dependencies","push","reduce","hasReducerNode","childReducerNode","add","scheduledForDeletion","parent","hasCollectionNode","collectionNode","getCollectionNode","getLinkedCollection","contains","addProp","isObject","dots","value","key","addFieldIfRequired","hasField","nestedFields","fieldNodes","filter","name","startsWith","node","remove","fieldNode","every","field"],"mappings":"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","sourcesContent":["import dot from 'dot-object';\nimport { createNodes } from '../../lib/createGraph';\nimport CollectionNode from '../../nodes/collectionNode';\nimport FieldNode from '../../nodes/fieldNode';\nimport ReducerNode from '../../nodes/reducerNode';\nimport embedReducerWithLink from './embedReducerWithLink';\nimport { specialFields } from '../../lib/createGraph';\n\nexport default function addReducers(root) {\n    // we add reducers last, after we have added all the fields.\n    root.reducerNodes.forEach(reducer => {\n        _.each(reducer.body, (body, fieldName) => {\n            handleAddElement(reducer, root, fieldName, body);\n        })\n    });\n}\n\n/**\n * @param root\n * @param fieldName\n * @param body\n */\nexport function handleAddElement(reducerNode, root, fieldName, body) {\n    // if it's a link\n    const collection = root.collection;\n    const linker = collection.getLinker(fieldName);\n    if (linker) {\n        return handleAddLink(reducerNode, fieldName, body, root, linker);\n    }\n\n    const reducer = collection.getReducer(fieldName);\n    if (reducer) {\n        reducerNode.dependencies.push(fieldName);\n        return handleAddReducer(fieldName, reducer, root);\n    }\n\n    // we assume it's a field in this case\n    return handleAddField(fieldName, body, root);\n}\n\n/**\n * @param fieldName\n * @param reducer\n * @param root\n */\nexport function handleAddReducer(fieldName, {body, reduce}, root) {\n    if (!root.hasReducerNode(fieldName)) {\n        let childReducerNode = new ReducerNode(fieldName, {body, reduce});\n        root.add(childReducerNode);\n        childReducerNode.scheduledForDeletion = true;\n\n        _.each(childReducerNode.body, (body, fieldName) => {\n            handleAddElement(childReducerNode, root, fieldName, body);\n        })\n    }\n}\n\n/**\n * @param fieldName\n * @param body\n * @param root\n * @param linker\n */\nexport function handleAddLink(reducerNode, fieldName, body, parent, linker) {\n    if (parent.hasCollectionNode(fieldName)) {\n        const collectionNode = parent.getCollectionNode(fieldName);\n\n        embedReducerWithLink(reducerNode, body, collectionNode);\n    } else {\n        // add\n        let collectionNode = new CollectionNode(linker.getLinkedCollection(), body, fieldName);\n        collectionNode.scheduledForDeletion = true;\n        parent.add(collectionNode, linker);\n\n        createNodes(collectionNode);\n    }\n}\n\n/**\n * @param fieldName\n * @param body\n * @param root\n */\nexport function handleAddField(fieldName, body, root) {\n    if (_.contains(specialFields, fieldName)) {\n        root.addProp(fieldName, body);\n\n        return;\n    }\n\n    if (_.isObject(body)) {\n        // if reducer specifies a nested field\n        // if it's a prop\n        const dots = dot.dot({\n            [fieldName]: body\n        });\n\n        _.each(dots, (value, key) => {\n            addFieldIfRequired(root, key, value);\n        });\n    } else {\n        // if reducer does not specify a nested field, and the field does not exist.\n        addFieldIfRequired(root, fieldName, body);\n    }\n}\n\nfunction addFieldIfRequired(root, fieldName, body) {\n    if (!root.hasField(fieldName, true)) {\n        /**\n         * Check if there are any nested fields for this field.\n         * Adding root field here and scheduling for deletion would not work if there is already nested field, \n         * for example:\n         * when trying to add meta: 1, it should be checked that there are no meta.* fields\n         * */\n\n        const nestedFields = root.fieldNodes.filter(({name}) => name.startsWith(`${fieldName}.`));\n        // remove nested fields - important for minimongo which complains for these situations\n        // TODO: excess fields are not removed (caused by adding the root field and removing nested fields) but there\n        // should probably be a way to handle this in post-processing - for example by keeping a whitelist of fields\n        // and removing anything else\n        nestedFields.forEach(node => root.remove(node));\n \n        let fieldNode = new FieldNode(fieldName, body);\n        // delete only if all nested fields are scheduled for deletion (that includes the case of 0 nested fields)\n        fieldNode.scheduledForDeletion = nestedFields.every(field => field.scheduledForDeletion);\n\n        root.add(fieldNode);\n    }\n}\n"]},"sourceType":"script","hash":"05e40e332ac56c5565514726d79cbbca66d0fafa"}
