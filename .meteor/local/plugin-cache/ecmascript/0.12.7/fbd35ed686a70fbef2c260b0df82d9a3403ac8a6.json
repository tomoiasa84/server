{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","passPerPreset":false,"envName":"development","cwd":"/Users/simiontomoiaga/git/server","root":"/Users/simiontomoiaga/git/server","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/simiontomoiaga/git/server/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"}},"code":"module.export({\n  applyPostFilters: () => applyPostFilters,\n  applyPostOptions: () => applyPostOptions,\n  getResultsArray: () => getResultsArray,\n  removeLinkStorages: () => removeLinkStorages,\n  storeOneResults: () => storeOneResults,\n  assembleMetadata: () => assembleMetadata\n});\nlet applyReducers;\nmodule.link(\"../reducers/lib/applyReducers\", {\n  default(v) {\n    applyReducers = v;\n  }\n\n}, 0);\nlet cleanReducerLeftovers;\nmodule.link(\"../reducers/lib/cleanReducerLeftovers\", {\n  default(v) {\n    cleanReducerLeftovers = v;\n  }\n\n}, 1);\nlet sift;\nmodule.link(\"sift\", {\n  default(v) {\n    sift = v;\n  }\n\n}, 2);\nlet Minimongo;\nmodule.link(\"meteor/minimongo\", {\n  Minimongo(v) {\n    Minimongo = v;\n  }\n\n}, 3);\nmodule.exportDefault((node, params) => {\n  snapBackCaches(node);\n  storeOneResults(node, node.results);\n  applyReducers(node, params);\n\n  _.each(node.collectionNodes, collectionNode => {\n    cloneMetaChildren(collectionNode, node.results);\n  });\n\n  _.each(node.collectionNodes, collectionNode => {\n    assembleMetadata(collectionNode, node.results);\n  });\n\n  cleanReducerLeftovers(node, node.results);\n  removeLinkStorages(node, node.results);\n  applyPostFilters(node);\n  applyPostOptions(node);\n  applyPostFilter(node, params);\n});\n\nfunction applyPostFilters(node) {\n  const postFilters = node.props.$postFilters;\n\n  if (postFilters) {\n    node.results = sift(postFilters, node.results);\n  }\n}\n\nfunction applyPostOptions(node) {\n  const options = node.props.$postOptions;\n\n  if (options) {\n    if (options.sort) {\n      const sorter = new Minimongo.Sorter(options.sort);\n      node.results.sort(sorter.getComparator());\n    }\n\n    if (options.limit || options.skip) {\n      const start = options.skip || 0;\n      const end = options.limit ? options.limit + start : node.results.length;\n      node.results = node.results.slice(start, end);\n    }\n  }\n}\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n  if (node.props.$postFilter) {\n    const filter = node.props.$postFilter;\n\n    if (_.isArray(filter)) {\n      filter.forEach(f => {\n        node.results = f(node.results, params);\n      });\n    } else {\n      node.results = filter(node.results, params);\n    }\n  }\n}\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\n\n\nfunction getResultsArray(results) {\n  if (_.isArray(results)) {\n    return results;\n  } else if (_.isUndefined(results)) {\n    return [];\n  }\n\n  return [results];\n}\n\nfunction removeLinkStorages(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  sameLevelResults = getResultsArray(sameLevelResults);\n\n  _.each(node.collectionNodes, collectionNode => {\n    const removeStorageField = collectionNode.shouldCleanStorage;\n\n    _.each(sameLevelResults, result => {\n      if (removeStorageField) {\n        if (collectionNode.isVirtual) {\n          const childResults = getResultsArray(result[collectionNode.linkName]);\n\n          _.each(childResults, childResult => {\n            delete childResult[collectionNode.linkStorageField];\n          });\n        } else {\n          delete result[collectionNode.linkStorageField];\n        }\n      }\n\n      removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n    });\n  });\n}\n\nfunction storeOneResults(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(sameLevelResults, result => {\n      // The reason we are doing this is that if the requested link does not exist\n      // It will fail when we try to get undefined[something] below\n      if (result === undefined) {\n        return;\n      }\n\n      storeOneResults(collectionNode, result[collectionNode.linkName]);\n    });\n\n    if (collectionNode.isOneResult) {\n      _.each(sameLevelResults, result => {\n        if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n          result[collectionNode.linkName] = result[collectionNode.linkName] ? _.first(result[collectionNode.linkName]) : undefined;\n        }\n      });\n    }\n  });\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n  if (!parentResults) {\n    return;\n  }\n\n  const linkName = node.linkName;\n  const isMeta = node.isMeta; // parentResults might be an object (for type==one links)\n\n  parentResults = getResultsArray(parentResults);\n  parentResults.forEach(parentResult => {\n    if (isMeta && parentResult[linkName]) {\n      if (node.isOneResult) {\n        parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n      } else {\n        parentResult[linkName] = parentResult[linkName].map(object => {\n          return Object.assign({}, object);\n        });\n      }\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n      cloneMetaChildren(collectionNode, parentResult[linkName]);\n    });\n  });\n}\n\nfunction assembleMetadata(node, parentResults) {\n  parentResults = getResultsArray(parentResults); // assembling metadata is depth first\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(parentResults, result => {\n      assembleMetadata(collectionNode, result[node.linkName]);\n    });\n  });\n\n  if (node.isMeta) {\n    if (node.isVirtual) {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n\n        if (node.isOneResult) {\n          if (_.isObject(childResult)) {\n            const storage = childResult[node.linkStorageField];\n            storeMetadata(childResult, parentResult, storage, true);\n          }\n        } else {\n          _.each(childResult, object => {\n            const storage = object[node.linkStorageField];\n            storeMetadata(object, parentResult, storage, true);\n          });\n        }\n      });\n    } else {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n        const storage = parentResult[node.linkStorageField];\n\n        if (node.isOneResult) {\n          if (childResult) {\n            storeMetadata(childResult, parentResult, storage, false);\n          }\n        } else {\n          _.each(childResult, object => {\n            storeMetadata(object, parentResult, storage, false);\n          });\n        }\n      });\n    }\n  }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n  if (isVirtual) {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  } else {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  }\n}\n\nfunction snapBackCaches(node) {\n  node.collectionNodes.forEach(collectionNode => {\n    snapBackCaches(collectionNode);\n  });\n\n  if (!_.isEmpty(node.snapCaches)) {\n    // process stuff\n    _.each(node.snapCaches, (linkName, cacheField) => {\n      const isSingle = _.contains(node.snapCachesSingles, cacheField);\n\n      const linker = node.collection.getLinker(linkName); // we do this because for one direct and one meta direct, id is not stored\n\n      const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n      node.results.forEach(result => {\n        if (result[cacheField]) {\n          if (shoudStoreLinkStorage) {\n            Object.assign(result[cacheField], {\n              _id: linker.isMeta() ? result[linker.linkStorageField]._id : result[linker.linkStorageField]\n            });\n          }\n\n          if (isSingle && _.isArray(result[cacheField])) {\n            result[linkName] = _.first(result[cacheField]);\n          } else {\n            result[linkName] = result[cacheField];\n          }\n\n          delete result[cacheField];\n        }\n      });\n    });\n  }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"],"names":["module","export","applyPostFilters","applyPostOptions","getResultsArray","removeLinkStorages","storeOneResults","assembleMetadata","applyReducers","link","default","v","cleanReducerLeftovers","sift","Minimongo","exportDefault","node","params","snapBackCaches","results","_","each","collectionNodes","collectionNode","cloneMetaChildren","applyPostFilter","postFilters","props","$postFilters","options","$postOptions","sort","sorter","Sorter","getComparator","limit","skip","start","end","length","slice","$postFilter","filter","isArray","forEach","f","isUndefined","sameLevelResults","removeStorageField","shouldCleanStorage","result","isVirtual","childResults","linkName","childResult","linkStorageField","undefined","isOneResult","first","parentResults","isMeta","parentResult","Object","assign","map","object","isObject","storage","storeMetadata","element","parentElement","$metadata","find","storageItem","_id","omit","isEmpty","snapCaches","cacheField","isSingle","contains","snapCachesSingles","linker","collection","getLinker","shoudStoreLinkStorage","isMany"],"mappings":"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","sourcesContent":["// 1. Clone children with meta relationships\n// 2. Apply $metadata to children\n// 3. Removes link storage (if not specified)\n// 4. Stores oneResult links as a single object instead of array\nimport applyReducers from '../reducers/lib/applyReducers';\nimport cleanReducerLeftovers from '../reducers/lib/cleanReducerLeftovers';\nimport sift from 'sift';\nimport {Minimongo} from 'meteor/minimongo';\n\nexport default (node, params) => {\n    snapBackCaches(node);\n    storeOneResults(node, node.results);\n\n    applyReducers(node, params);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results)\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results)\n    });\n\n    cleanReducerLeftovers(node, node.results);\n\n    removeLinkStorages(node, node.results);\n\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n}\n\nexport function applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nexport function applyPostOptions(node) {\n    const options = node.props.$postOptions;\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            })\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\nexport function getResultsArray(results) {\n    if (_.isArray(results)) {\n        return results;\n    }\n    else if (_.isUndefined(results)) {\n        return [];\n    }\n    return [results];\n}\n\nexport function removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    sameLevelResults = getResultsArray(sameLevelResults);\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n     \n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                if (collectionNode.isVirtual) {\n                    const childResults = getResultsArray(result[collectionNode.linkName]);\n                    _.each(childResults, childResult => {\n                        delete childResult[collectionNode.linkStorageField];\n                    });\n                } else {\n                    delete result[collectionNode.linkStorageField];\n                }\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        })\n    })\n}\n\nexport function storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            // The reason we are doing this is that if the requested link does not exist\n            // It will fail when we try to get undefined[something] below\n            if (result === undefined) {\n                return;\n            }\n\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            _.each(sameLevelResults, result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName]\n                        ? _.first(result[collectionNode.linkName])\n                        : undefined;\n                }\n            })\n        }\n    })\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n\n    // parentResults might be an object (for type==one links)\n    parentResults = getResultsArray(parentResults);\n\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            if (node.isOneResult) {\n                parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n            }\n            else {\n                parentResult[linkName] = parentResult[linkName].map(object => {\n                    return Object.assign({}, object);\n                });\n            }\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nexport function assembleMetadata(node, parentResults) {\n    parentResults = getResultsArray(parentResults);\n\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName])\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                if (node.isOneResult) {\n                    if (_.isObject(childResult)) {\n                        const storage = childResult[node.linkStorageField];\n                        storeMetadata(childResult, parentResult, storage, true);\n                    }\n                } else {\n                    _.each(childResult, object => {\n                        const storage = object[node.linkStorageField];\n                        storeMetadata(object, parentResult, storage, true);\n                    });\n                }\n            })\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                if (node.isOneResult) {\n                    if (childResult) {\n                        storeMetadata(childResult, parentResult, storage, false);\n                    }\n                } else {\n                    _.each(childResult, object => {\n                        storeMetadata(object, parentResult, storage, false);\n                    });\n                }\n            })\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id')\n    } else {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n            const linker = node.collection.getLinker(linkName);\n            // we do this because for one direct and one meta direct, id is not stored\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta()\n                                ? result[linker.linkStorageField]._id\n                                : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            })\n        })\n    }\n}\n"]},"sourceType":"script","hash":"fbd35ed686a70fbef2c260b0df82d9a3403ac8a6"}
