[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar CollectionHooks = Package['matb33:collection-hooks'].CollectionHooks;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"herteby:denormalize\":{\"cache.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cache.js                                                                  //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.export({\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration, migrate, autoMigrate;\nmodule.watch(require(\"./migrations.js\"), {\n  addMigration(v) {\n    addMigration = v;\n  },\n\n  migrate(v) {\n    migrate = v;\n  },\n\n  autoMigrate(v) {\n    autoMigrate = v;\n  }\n\n}, 1);\n\nfunction flattenFields(object, prefix) {\n  prefix = prefix || '';\n  let fields = [];\n\n  _.each(object, (val, key) => {\n    if (typeof val == 'object') {\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'));\n    } else {\n      fields.push(prefix + key);\n    }\n  });\n\n  return fields;\n}\n\nMongo.Collection.prototype.cache = function (options) {\n  check(options, {\n    collection: Match.Where(collection => collection instanceof Mongo.Collection),\n    fields: Match.OneOf([String], Object),\n    type: Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField: String,\n    cacheField: String,\n    bypassSchema: Match.Optional(Boolean)\n  });\n  if (options.type == 'inverse') options.type = 'inversed'; //Not sure which is best, so why not support both and be typo-friendly\n\n  if (options.type == 'many-inverse') options.type = 'many-inversed'; //Bypass collection2 schemas\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let type = options.type;\n  let referenceField = options.referenceField;\n  let cacheField = options.cacheField;\n  let watchedFields = options.fields;\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  if (!_.isArray(watchedFields)) {\n    watchedFields = flattenFields(watchedFields);\n  }\n\n  let childFields = _.clone(watchedFields);\n\n  if (type !== 'one') {\n    if (!_.includes(childFields, '_id')) {\n      childFields.push('_id');\n    }\n\n    _.pull(childFields, referenceField);\n  }\n\n  let childOpts = {\n    transform: null,\n    fields: {\n      _id: 0\n    }\n  };\n\n  _.each(childFields, field => childOpts.fields[field] = 1);\n\n  let parentOpts = {\n    transform: null,\n    fields: {\n      _id: 1,\n      [cacheField]: 1\n    }\n  };\n\n  if (type !== 'inversed' && type !== 'many-inversed') {\n    parentOpts.fields[referenceField.split(':')[0]] = 1;\n  }\n\n  let idField, referencePath;\n\n  if (type == 'many' || type == 'many-inversed') {\n    referencePath = referenceField.replace(':', '.');\n    idField = referenceField.split(':')[1];\n    referenceField = referenceField.split(':')[0];\n  }\n\n  if (type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)) {\n    watchedFields.push(referencePath || referenceField);\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]));\n\n  function getNestedReferences(document) {\n    //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || [];\n\n    if (idField && references.length) {\n      references = _.map(references, item => _.get(item, idField));\n    }\n\n    return _.uniq(_.flatten(references));\n  }\n\n  if (type == 'one') {\n    let insert = function insert(userId, parent) {\n      if (_.get(parent, referenceField)) {\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        }\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $unset: {\n              [cacheField]: 1\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $set: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          [referenceField]: child._id\n        }, {\n          $set: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $unset: {\n          [cacheField]: 1\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'many') {\n    let insert = function insert(userId, parent) {\n      let references = getNestedReferences(parent);\n\n      if (references.length) {\n        let children = childCollection.find({\n          _id: {\n            $in: references\n          }\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      } else {\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: []\n          }\n        });\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let references = getNestedReferences(parent);\n\n        if (references.length) {\n          let children = childCollection.find({\n            _id: {\n              $in: references\n            }\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $push: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.find({\n          [referencePath]: child._id\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referenceField]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        if (_.get(parent, referenceField)) {\n          let children = childCollection.find({\n            [referenceField]: parent._id\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      if (_.get(child, referenceField)) {\n        parentCollection.update({\n          _id: _.get(child, referenceField)\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        let previousId = this.previous && _.get(this.previous, referenceField);\n\n        if (previousId && previousId !== _.get(child, referenceField)) {\n          parentCollection.update({\n            _id: previousId\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          });\n        }\n\n        parentCollection.find({\n          _id: _.get(child, referenceField)\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        _id: _.get(child, referenceField)\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      });\n    });\n  } else if (type == 'many-inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referencePath]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let children = childCollection.find({\n          [referencePath]: parent._id\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let references = getNestedReferences(child);\n        let previousIds = this.previous && getNestedReferences(this.previous);\n        previousIds = _.difference(previousIds, references);\n\n        if (previousIds.length) {\n          parentCollection.update({\n            _id: {\n              $in: previousIds\n            }\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          }, {\n            multi: true\n          });\n        }\n\n        if (references.length) {\n          let pickedChild = _.pick(child, childFields);\n\n          parentCollection.find({\n            _id: {\n              $in: references\n            }\n          }, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {\n              _id: child._id\n            });\n\n            if (index > -1) {\n              parentCollection.update(parent._id, {\n                $set: {\n                  [cacheField + '.' + index]: pickedChild\n                }\n              });\n            } else {\n              parentCollection.update(parent._id, {\n                $push: {\n                  [cacheField]: pickedChild\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $pull: {\n            [cacheField]: {\n              _id: child._id\n            }\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n  }\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cacheCount.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cacheCount.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nlet _;\n\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration;\nmodule.watch(require(\"./migrations.js\"), {\n  addMigration(v) {\n    addMigration = v;\n  }\n\n}, 1);\n\nMongo.Collection.prototype.cacheCount = function (options) {\n  check(options, {\n    collection: Mongo.Collection,\n    cacheField: String,\n    referenceField: String,\n    selector: Match.Optional(Object),\n    bypassSchema: Match.Optional(Boolean)\n  });\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let selector = options.selector || {};\n  let cacheField = options.cacheField;\n  let referenceField = options.referenceField;\n\n  let watchedFields = _.union([referenceField], _.keys(selector));\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  function update(child) {\n    let ref = _.get(child, referenceField);\n\n    if (ref) {\n      let select = _.merge(selector, {\n        [referenceField]: ref\n      });\n\n      parentCollection.update({\n        _id: ref\n      }, {\n        $set: {\n          [cacheField]: childCollection.find(select).count()\n        }\n      });\n    }\n  }\n\n  function insert(userId, parent) {\n    let select = _.merge(selector, {\n      [referenceField]: parent._id\n    });\n\n    parentCollection.update(parent._id, {\n      $set: {\n        [cacheField]: childCollection.find(select).count()\n      }\n    });\n  }\n\n  addMigration(parentCollection, insert, options);\n  parentCollection.after.insert(insert);\n  childCollection.after.insert((userId, child) => {\n    update(child);\n  });\n  childCollection.after.update((userId, child, changedFields) => {\n    if (_.intersection(changedFields, watchedFields).length) {\n      update(child);\n      update(this.previous);\n    }\n  });\n  childCollection.after.remove((userId, child) => {\n    update(child);\n  });\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cacheField.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cacheField.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nlet _;\n\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration;\nmodule.watch(require(\"./migrations.js\"), {\n  addMigration(v) {\n    addMigration = v;\n  }\n\n}, 1);\n\nMongo.Collection.prototype.cacheField = function (options) {\n  check(options, {\n    cacheField: String,\n    fields: [String],\n    transform: Match.Optional(Function),\n    bypassSchema: Match.Optional(Boolean)\n  });\n  let collection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let cacheField = options.cacheField;\n  let fields = options.fields;\n\n  let topFields = _.uniq(_.map(fields, field => field.split('.')[0]));\n\n  let transform = options.transform;\n\n  if (!transform) {\n    transform = function (doc) {\n      return _.compact(_.map(fields, field => _.get(doc, field))).join(', ');\n    };\n  }\n\n  if (_.includes(topFields, cacheField.split(/[.:]/)[0])) {\n    throw new Error('watching the cacheField for changes would cause an infinite loop');\n  }\n\n  function insertHook(userid, doc) {\n    collection.update(doc._id, {\n      $set: {\n        [cacheField]: transform(_.pick(doc, fields))\n      }\n    });\n  }\n\n  addMigration(collection, insertHook, options);\n  collection.after.insert(insertHook);\n  collection.after.update((userId, doc, changedFields) => {\n    if (_.intersection(changedFields, topFields).length) {\n      Meteor.defer(() => {\n        collection.update(doc._id, {\n          $set: {\n            [cacheField]: transform(_.pick(doc, fields))\n          }\n        });\n      });\n    }\n  });\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"migrations.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/migrations.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.export({\n  MigrationHistory: () => MigrationHistory,\n  addMigration: () => addMigration,\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet Mongo;\nmodule.watch(require(\"meteor/mongo\"), {\n  Mongo(v) {\n    Mongo = v;\n  }\n\n}, 1);\nlet settings;\nmodule.watch(require(\"./cache.js\"), {\n  default(v) {\n    settings = v;\n  }\n\n}, 2);\nconst MigrationHistory = new Mongo.Collection('_cacheMigrations');\nlet migrations = [];\n\nfunction addMigration(collection, insertFn, options) {\n  let opts = _.clone(options);\n\n  if (opts.collection) {\n    //prevent Error: Converting circular structure to JSON\n    opts.collection = opts.collection._name;\n  }\n\n  opts = JSON.stringify(opts);\n  migrations.push({\n    options: opts,\n    collectionName: collection._name,\n    collection: collection,\n    cacheField: options.cacheField,\n    fn: insertFn\n  });\n}\n\nfunction migrate(collectionName, cacheField, selector) {\n  let migration = _.find(migrations, {\n    collectionName,\n    cacheField\n  });\n\n  if (!migration) {\n    throw new Error('no migration found for ' + collectionName + ' - ' + cacheField);\n  } else {\n    let time = new Date();\n    let n = 0;\n    migration.collection.find(selector || {}).forEach(doc => {\n      migration.fn(null, doc);\n      n++;\n    });\n    console.log(`migrated ${cacheField} of ${n} docs in ${collectionName + (selector ? ' matching ' + JSON.stringify(selector) : '')}. It took ${new Date() - time}ms`);\n  }\n}\n\nfunction autoMigrate() {\n  _.each(migrations, migration => {\n    if (!MigrationHistory.findOne({\n      collectionName: migration.collectionName,\n      options: migration.options\n    })) {\n      migrate(migration.collectionName, migration.cacheField);\n      MigrationHistory.insert({\n        collectionName: migration.collectionName,\n        options: migration.options,\n        date: new Date()\n      });\n    }\n  });\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"lodash\":{\"package.json\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// node_modules/meteor/herteby_denormalize/node_modules/lodash/package.json                               //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nexports.name = \"lodash\";\nexports.version = \"4.17.4\";\nexports.main = \"lodash.js\";\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lodash.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// node_modules/meteor/herteby_denormalize/node_modules/lodash/lodash.js                                  //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.useNode();\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/herteby:denormalize/cache.js\");\nrequire(\"/node_modules/meteor/herteby:denormalize/cacheCount.js\");\nrequire(\"/node_modules/meteor/herteby:denormalize/cacheField.js\");\n\n/* Exports */\nPackage._define(\"herteby:denormalize\", exports);\n\n})();\n","servePath":"/packages/herteby_denormalize.js","sourceMap":{"version":3,"sources":["packages/herteby:denormalize/cache.js","packages/herteby:denormalize/cacheCount.js","packages/herteby:denormalize/cacheField.js","packages/herteby:denormalize/migrations.js"],"names":["module","export","migrate","autoMigrate","_","watch","require","default","v","addMigration","flattenFields","object","prefix","fields","each","val","key","union","push","Mongo","Collection","prototype","cache","options","check","collection","Match","Where","OneOf","String","Object","type","referenceField","cacheField","bypassSchema","Optional","Boolean","parentCollection","Package","_collection","childCollection","watchedFields","split","Error","isArray","childFields","clone","includes","pull","childOpts","transform","_id","field","parentOpts","idField","referencePath","replace","topFields","uniq","map","getNestedReferences","document","references","get","length","item","flatten","insert","userId","parent","child","findOne","update","$set","after","changedFields","$unset","pickedChild","pick","multi","intersection","remove","children","find","$in","fetch","$push","forEach","index","findIndex","$pull","previousId","previous","previousIds","difference","cacheCount","selector","keys","ref","select","merge","count","Function","doc","compact","join","insertHook","userid","Meteor","defer","MigrationHistory","settings","migrations","insertFn","opts","_name","JSON","stringify","collectionName","fn","migration","time","Date","n","console","log","date"],"mappings":"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","file":"/packages/herteby_denormalize.js","sourcesContent":["import _ from 'lodash'\nimport {addMigration, migrate, autoMigrate} from './migrations.js'\n\nexport {migrate, autoMigrate}\n\nfunction flattenFields(object, prefix){\n  prefix = prefix || ''\n  let fields = []\n  _.each(object, (val, key) => {\n    if(typeof val == 'object'){\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'))\n    } else {\n      fields.push(prefix + key)\n    }\n  })\n  return fields\n}\n\nMongo.Collection.prototype.cache = function(options){\n  check(options, {\n    collection:Match.Where(collection => collection instanceof Mongo.Collection),\n    fields:Match.OneOf([String], Object),\n    type:Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField:String,\n    cacheField:String,\n    bypassSchema:Match.Optional(Boolean)\n  })\n  if(options.type == 'inverse') options.type = 'inversed' //Not sure which is best, so why not support both and be typo-friendly\n  if(options.type == 'many-inverse') options.type = 'many-inversed'\n\n  //Bypass collection2 schemas\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let type = options.type\n  let referenceField = options.referenceField\n  let cacheField = options.cacheField\n  let watchedFields = options.fields\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  if(!_.isArray(watchedFields)){\n    watchedFields = flattenFields(watchedFields)\n  }\n\n  let childFields = _.clone(watchedFields)\n  if(type !== 'one'){\n    if(!_.includes(childFields, '_id')){\n      childFields.push('_id')\n    }\n    _.pull(childFields, referenceField)\n  }\n  let childOpts = {transform:null, fields:{_id:0}}\n  _.each(childFields, field => childOpts.fields[field] = 1)\n\n  let parentOpts = {transform:null, fields:{_id:1, [cacheField]:1}}\n  if(type !== 'inversed' && type !== 'many-inversed'){\n    parentOpts.fields[referenceField.split(':')[0]] = 1\n  }\n\n  let idField, referencePath\n  if(type == 'many' || type == 'many-inversed'){\n    referencePath = referenceField.replace(':', '.')\n    idField = referenceField.split(':')[1]\n    referenceField = referenceField.split(':')[0]\n  }\n\n  if(type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)){\n    watchedFields.push(referencePath || referenceField)\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]))\n\n  function getNestedReferences(document){ //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || []\n    if(idField && references.length){\n      references = _.map(references, item => _.get(item, idField))\n    }\n    return _.uniq(_.flatten(references))\n  }\n\n\n  if(type == 'one'){\n    let insert = function insert(userId, parent){\n      if(_.get(parent, referenceField)){\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        }\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        } else {\n          parentCollection.update(parent._id, {$unset:{[cacheField]:1}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referenceField]:child._id}, {$unset:{[cacheField]:1}}, {multi:true})\n    })\n  } \n\n  else if(type == 'many'){\n    let insert = function insert(userId, parent){\n      let references = getNestedReferences(parent)\n      if(references.length){\n        let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      } else {\n        parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let references = getNestedReferences(parent)\n        if(references.length){\n          let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referencePath]:child._id}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.find({[referencePath]:child._id}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referencePath]:child._id}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n    })\n  }\n\n\n  else if(type == 'inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        if(_.get(parent, referenceField)){\n          let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      if(_.get(child, referenceField)){\n        parentCollection.update({_id:_.get(child, referenceField)}, {$push:{[cacheField]:pickedChild}})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        let previousId = this.previous && _.get(this.previous, referenceField)\n        if(previousId && previousId !== _.get(child, referenceField)){\n          parentCollection.update({_id:previousId}, {$pull:{[cacheField]:{_id:child._id}}})\n        }\n        parentCollection.find({_id:_.get(child, referenceField)}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({_id:_.get(child, referenceField)}, {$pull:{[cacheField]:{_id:child._id}}})\n    })\n  }\n\n  else if(type == 'many-inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){        \n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({_id:{$in:references}}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let references = getNestedReferences(child)\n        let previousIds = this.previous && getNestedReferences(this.previous)\n        previousIds = _.difference(previousIds, references)\n        if(previousIds.length){\n          parentCollection.update({_id:{$in:previousIds}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n        }\n        if(references.length){\n          let pickedChild = _.pick(child, childFields)\n          parentCollection.find({_id:{$in:references}}, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n            if(index > -1){\n              parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n            } else {\n              parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n            }\n          })\n        }\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){\n        parentCollection.update({_id:{$in:references}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n      }\n    })\n  }\n}","import _ from 'lodash'\nimport {addMigration} from './migrations.js'\n\nMongo.Collection.prototype.cacheCount = function(options) {\n  check(options, {\n    collection:Mongo.Collection,\n    cacheField:String,\n    referenceField:String,\n    selector:Match.Optional(Object),\n    bypassSchema:Match.Optional(Boolean)\n  })\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let selector = options.selector || {}\n  let cacheField = options.cacheField\n  let referenceField = options.referenceField\n  let watchedFields = _.union([referenceField], _.keys(selector))\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  function update(child){\n    let ref = _.get(child, referenceField)\n    if(ref){\n      let select = _.merge(selector, {[referenceField]:ref})\n      parentCollection.update({_id:ref}, {$set:{[cacheField]:childCollection.find(select).count()}})\n    }\n  }\n\n  function insert(userId, parent){\n    let select = _.merge(selector, {[referenceField]:parent._id})\n    parentCollection.update(parent._id, {$set:{[cacheField]:childCollection.find(select).count()}})\n  }\n\n  addMigration(parentCollection, insert, options)\n\n  parentCollection.after.insert(insert)\n  \n  childCollection.after.insert((userId, child) => {\n    update(child)\n  })\n\n  childCollection.after.update((userId, child, changedFields) => {\n    if(_.intersection(changedFields, watchedFields).length){\n      update(child)\n      update(this.previous)\n    }\n  })\n\n  childCollection.after.remove((userId, child) => {\n    update(child)\n  })\n}","import _ from 'lodash'\nimport {addMigration} from './migrations.js'\n\nMongo.Collection.prototype.cacheField = function(options) {\n\n  check(options, {\n    cacheField:String,\n    fields:[String],\n    transform:Match.Optional(Function),\n    bypassSchema:Match.Optional(Boolean)\n  })\n\n  let collection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let cacheField = options.cacheField\n  let fields = options.fields\n  let topFields = _.uniq(_.map(fields, field => field.split('.')[0]))\n  let transform = options.transform\n  if(!transform) {\n    transform = function(doc) {\n      return _.compact(_.map(fields, field => _.get(doc, field))).join(', ')\n    }\n  }\n\n  if(_.includes(topFields, cacheField.split(/[.:]/)[0])){\n    throw new Error('watching the cacheField for changes would cause an infinite loop')\n  }\n\n  function insertHook(userid, doc){\n    collection.update(doc._id, {$set:{[cacheField]:transform(_.pick(doc, fields))}})\n  }\n\n  addMigration(collection, insertHook, options)\n\n  collection.after.insert(insertHook)\n\n  collection.after.update((userId, doc, changedFields) => {\n    if(_.intersection(changedFields, topFields).length){\n      Meteor.defer(()=>{\n        collection.update(doc._id, {$set:{[cacheField]:transform(_.pick(doc, fields))}})\n      })\n    }\n  })  \n}\n","import _ from 'lodash'\nimport {Mongo} from 'meteor/mongo'\nimport settings from './cache.js'\n\nexport const MigrationHistory = new Mongo.Collection('_cacheMigrations')\n\nlet migrations = []\n\nexport function addMigration(collection, insertFn, options){\n  let opts = _.clone(options)\n  if(opts.collection){ //prevent Error: Converting circular structure to JSON\n    opts.collection = opts.collection._name\n  }\n  opts = JSON.stringify(opts)\n  migrations.push({\n    options:opts,\n    collectionName:collection._name,\n    collection:collection,\n    cacheField:options.cacheField,\n    fn:insertFn\n  })\n}\n\nexport function migrate(collectionName, cacheField, selector){\n  let migration = _.find(migrations, {collectionName, cacheField})\n  if(!migration){\n    throw new Error('no migration found for ' + collectionName + ' - ' + cacheField)\n  } else {\n    let time = new Date()\n    let n = 0\n    migration.collection.find(selector || {}).forEach(doc => {\n      migration.fn(null, doc)\n      n++\n    })\n    console.log(`migrated ${cacheField} of ${n} docs in ${collectionName + (selector ? ' matching ' + JSON.stringify(selector) : '')}. It took ${new Date() - time}ms`)\n  }\n}\n\nexport function autoMigrate(){\n  _.each(migrations, migration => {\n    if(!MigrationHistory.findOne({collectionName:migration.collectionName, options:migration.options})){\n      migrate(migration.collectionName, migration.cacheField)\n      MigrationHistory.insert({\n        collectionName:migration.collectionName,\n        options:migration.options,\n        date:new Date()\n      })\n    }    \n  })\n}"]}}]