[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar CollectionHooks = Package['matb33:collection-hooks'].CollectionHooks;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"herteby:denormalize\":{\"cache.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cache.js                                                                  //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.export({\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.link(\"lodash\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration, migrate, autoMigrate;\nmodule.link(\"./migrations.js\", {\n  addMigration(v) {\n    addMigration = v;\n  },\n\n  migrate(v) {\n    migrate = v;\n  },\n\n  autoMigrate(v) {\n    autoMigrate = v;\n  }\n\n}, 1);\n\nfunction flattenFields(object, prefix) {\n  prefix = prefix || '';\n  let fields = [];\n\n  _.each(object, (val, key) => {\n    if (typeof val == 'object') {\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'));\n    } else {\n      fields.push(prefix + key);\n    }\n  });\n\n  return fields;\n}\n\nMongo.Collection.prototype.cache = function (options) {\n  check(options, {\n    collection: Match.Where(collection => collection instanceof Mongo.Collection),\n    fields: Match.OneOf([String], Object),\n    type: Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField: String,\n    cacheField: String,\n    bypassSchema: Match.Optional(Boolean)\n  });\n  if (options.type == 'inverse') options.type = 'inversed'; //Not sure which is best, so why not support both and be typo-friendly\n\n  if (options.type == 'many-inverse') options.type = 'many-inversed'; //Bypass collection2 schemas\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let type = options.type;\n  let referenceField = options.referenceField;\n  let cacheField = options.cacheField;\n  let watchedFields = options.fields;\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  if (!_.isArray(watchedFields)) {\n    watchedFields = flattenFields(watchedFields);\n  }\n\n  let childFields = _.clone(watchedFields);\n\n  if (type !== 'one') {\n    if (!_.includes(childFields, '_id')) {\n      childFields.push('_id');\n    }\n\n    _.pull(childFields, referenceField);\n  }\n\n  let childOpts = {\n    transform: null,\n    fields: {\n      _id: 0\n    }\n  };\n\n  _.each(childFields, field => childOpts.fields[field] = 1);\n\n  let parentOpts = {\n    transform: null,\n    fields: {\n      _id: 1,\n      [cacheField]: 1\n    }\n  };\n\n  if (type !== 'inversed' && type !== 'many-inversed') {\n    parentOpts.fields[referenceField.split(':')[0]] = 1;\n  }\n\n  let idField, referencePath;\n\n  if (type == 'many' || type == 'many-inversed') {\n    referencePath = referenceField.replace(':', '.');\n    idField = referenceField.split(':')[1];\n    referenceField = referenceField.split(':')[0];\n  }\n\n  if (type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)) {\n    watchedFields.push(referencePath || referenceField);\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]));\n\n  function getNestedReferences(document) {\n    //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || [];\n\n    if (idField && references.length) {\n      references = _.map(references, item => _.get(item, idField));\n    }\n\n    return _.uniq(_.flatten(references));\n  }\n\n  if (type == 'one') {\n    let insert = function insert(userId, parent) {\n      if (_.get(parent, referenceField)) {\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        }\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts);\n\n        if (child) {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: child\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $unset: {\n              [cacheField]: 1\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $set: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          [referenceField]: child._id\n        }, {\n          $set: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referenceField]: child._id\n      }, {\n        $unset: {\n          [cacheField]: 1\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'many') {\n    let insert = function insert(userId, parent) {\n      let references = getNestedReferences(parent);\n\n      if (references.length) {\n        let children = childCollection.find({\n          _id: {\n            $in: references\n          }\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      } else {\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: []\n          }\n        });\n      }\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let references = getNestedReferences(parent);\n\n        if (references.length) {\n          let children = childCollection.find({\n            _id: {\n              $in: references\n            }\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $push: {\n          [cacheField]: pickedChild\n        }\n      }, {\n        multi: true\n      });\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.find({\n          [referencePath]: child._id\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        [referencePath]: child._id\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      }, {\n        multi: true\n      });\n    });\n  } else if (type == 'inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referenceField]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referenceField.split('.')[0])) {\n        if (_.get(parent, referenceField)) {\n          let children = childCollection.find({\n            [referenceField]: parent._id\n          }, childOpts).fetch();\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: children\n            }\n          });\n        } else {\n          parentCollection.update(parent._id, {\n            $set: {\n              [cacheField]: []\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let pickedChild = _.pick(child, childFields);\n\n      if (_.get(child, referenceField)) {\n        parentCollection.update({\n          _id: _.get(child, referenceField)\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let pickedChild = _.pick(child, childFields);\n\n        let previousId = this.previous && _.get(this.previous, referenceField);\n\n        if (previousId && previousId !== _.get(child, referenceField)) {\n          parentCollection.update({\n            _id: previousId\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          });\n        }\n\n        parentCollection.find({\n          _id: _.get(child, referenceField)\n        }, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {\n            _id: child._id\n          });\n\n          if (index > -1) {\n            parentCollection.update(parent._id, {\n              $set: {\n                [cacheField + '.' + index]: pickedChild\n              }\n            });\n          } else {\n            parentCollection.update(parent._id, {\n              $push: {\n                [cacheField]: pickedChild\n              }\n            });\n          }\n        });\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      parentCollection.update({\n        _id: _.get(child, referenceField)\n      }, {\n        $pull: {\n          [cacheField]: {\n            _id: child._id\n          }\n        }\n      });\n    });\n  } else if (type == 'many-inversed') {\n    let insert = function insert(userId, parent) {\n      let children = childCollection.find({\n        [referencePath]: parent._id\n      }, childOpts).fetch();\n      parentCollection.update(parent._id, {\n        $set: {\n          [cacheField]: children\n        }\n      });\n    };\n\n    addMigration(parentCollection, insert, options);\n    parentCollection.after.insert(insert);\n    parentCollection.after.update(function (userId, parent, changedFields) {\n      if (_.includes(changedFields, referencePath.split('.')[0])) {\n        let children = childCollection.find({\n          [referencePath]: parent._id\n        }, childOpts).fetch();\n        parentCollection.update(parent._id, {\n          $set: {\n            [cacheField]: children\n          }\n        });\n      }\n    });\n    childCollection.after.insert(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        let pickedChild = _.pick(child, childFields);\n\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $push: {\n            [cacheField]: pickedChild\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n    childCollection.after.update(function (userId, child, changedFields) {\n      if (_.intersection(changedFields, topFields).length) {\n        let references = getNestedReferences(child);\n        let previousIds = this.previous && getNestedReferences(this.previous);\n        previousIds = _.difference(previousIds, references);\n\n        if (previousIds.length) {\n          parentCollection.update({\n            _id: {\n              $in: previousIds\n            }\n          }, {\n            $pull: {\n              [cacheField]: {\n                _id: child._id\n              }\n            }\n          }, {\n            multi: true\n          });\n        }\n\n        if (references.length) {\n          let pickedChild = _.pick(child, childFields);\n\n          parentCollection.find({\n            _id: {\n              $in: references\n            }\n          }, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {\n              _id: child._id\n            });\n\n            if (index > -1) {\n              parentCollection.update(parent._id, {\n                $set: {\n                  [cacheField + '.' + index]: pickedChild\n                }\n              });\n            } else {\n              parentCollection.update(parent._id, {\n                $push: {\n                  [cacheField]: pickedChild\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    childCollection.after.remove(function (userId, child) {\n      let references = getNestedReferences(child);\n\n      if (references.length) {\n        parentCollection.update({\n          _id: {\n            $in: references\n          }\n        }, {\n          $pull: {\n            [cacheField]: {\n              _id: child._id\n            }\n          }\n        }, {\n          multi: true\n        });\n      }\n    });\n  }\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cacheCount.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cacheCount.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nlet _;\n\nmodule.link(\"lodash\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration;\nmodule.link(\"./migrations.js\", {\n  addMigration(v) {\n    addMigration = v;\n  }\n\n}, 1);\n\nMongo.Collection.prototype.cacheCount = function (options) {\n  check(options, {\n    collection: Mongo.Collection,\n    cacheField: String,\n    referenceField: String,\n    selector: Match.Optional(Object),\n    bypassSchema: Match.Optional(Boolean)\n  });\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let childCollection = options.collection;\n  let selector = options.selector || {};\n  let cacheField = options.cacheField;\n  let referenceField = options.referenceField;\n\n  let watchedFields = _.union([referenceField], _.keys(selector));\n\n  if (referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]) {\n    throw new Error('referenceField and cacheField must not share the same top field');\n  }\n\n  function update(child) {\n    let ref = _.get(child, referenceField);\n\n    if (ref) {\n      let select = _.merge(selector, {\n        [referenceField]: ref\n      });\n\n      parentCollection.update({\n        _id: ref\n      }, {\n        $set: {\n          [cacheField]: childCollection.find(select).count()\n        }\n      });\n    }\n  }\n\n  function insert(userId, parent) {\n    let select = _.merge(selector, {\n      [referenceField]: parent._id\n    });\n\n    parentCollection.update(parent._id, {\n      $set: {\n        [cacheField]: childCollection.find(select).count()\n      }\n    });\n  }\n\n  addMigration(parentCollection, insert, options);\n  parentCollection.after.insert(insert);\n  childCollection.after.insert((userId, child) => {\n    update(child);\n  });\n  childCollection.after.update((userId, child, changedFields) => {\n    if (_.intersection(changedFields, watchedFields).length) {\n      update(child);\n      update(this.previous);\n    }\n  });\n  childCollection.after.remove((userId, child) => {\n    update(child);\n  });\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cacheField.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/cacheField.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nlet _;\n\nmodule.link(\"lodash\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet addMigration;\nmodule.link(\"./migrations.js\", {\n  addMigration(v) {\n    addMigration = v;\n  }\n\n}, 1);\n\nMongo.Collection.prototype.cacheField = function (options) {\n  check(options, {\n    cacheField: String,\n    fields: [String],\n    transform: Match.Optional(Function),\n    bypassSchema: Match.Optional(Boolean)\n  });\n  let collection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this;\n  let cacheField = options.cacheField;\n  let fields = options.fields;\n\n  let topFields = _.uniq(_.map(fields, field => field.split('.')[0]));\n\n  let transform = options.transform;\n\n  if (!transform) {\n    transform = function (doc) {\n      return _.compact(_.map(fields, field => _.get(doc, field))).join(', ');\n    };\n  }\n\n  if (_.includes(topFields, cacheField.split(/[.:]/)[0])) {\n    throw new Error('watching the cacheField for changes would cause an infinite loop');\n  }\n\n  function insertHook(userid, doc) {\n    collection.update(doc._id, {\n      $set: {\n        [cacheField]: transform(_.pick(doc, fields))\n      }\n    });\n  }\n\n  addMigration(collection, insertHook, options);\n  collection.after.insert(insertHook);\n  collection.after.update((userId, doc, changedFields) => {\n    if (_.intersection(changedFields, topFields).length) {\n      Meteor.defer(() => {\n        collection.update(doc._id, {\n          $set: {\n            [cacheField]: transform(_.pick(doc, fields))\n          }\n        });\n      });\n    }\n  });\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"migrations.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/herteby_denormalize/migrations.js                                                             //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.export({\n  MigrationHistory: () => MigrationHistory,\n  addMigration: () => addMigration,\n  migrate: () => migrate,\n  autoMigrate: () => autoMigrate\n});\n\nlet _;\n\nmodule.link(\"lodash\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet Mongo;\nmodule.link(\"meteor/mongo\", {\n  Mongo(v) {\n    Mongo = v;\n  }\n\n}, 1);\nlet settings;\nmodule.link(\"./cache.js\", {\n  default(v) {\n    settings = v;\n  }\n\n}, 2);\nconst MigrationHistory = new Mongo.Collection('_cacheMigrations');\nlet migrations = [];\n\nfunction addMigration(collection, insertFn, options) {\n  let opts = _.clone(options);\n\n  if (opts.collection) {\n    //prevent Error: Converting circular structure to JSON\n    opts.collection = opts.collection._name;\n  }\n\n  opts = JSON.stringify(opts);\n  migrations.push({\n    options: opts,\n    collectionName: collection._name,\n    collection: collection,\n    cacheField: options.cacheField,\n    fn: insertFn\n  });\n}\n\nfunction migrate(collectionName, cacheField, selector) {\n  let migration = _.find(migrations, {\n    collectionName,\n    cacheField\n  });\n\n  if (!migration) {\n    throw new Error('no migration found for ' + collectionName + ' - ' + cacheField);\n  } else {\n    let time = new Date();\n    let n = 0;\n    migration.collection.find(selector || {}).forEach(doc => {\n      migration.fn(null, doc);\n      n++;\n    });\n    console.log(`migrated ${cacheField} of ${n} docs in ${collectionName + (selector ? ' matching ' + JSON.stringify(selector) : '')}. It took ${new Date() - time}ms`);\n  }\n}\n\nfunction autoMigrate() {\n  _.each(migrations, migration => {\n    if (!MigrationHistory.findOne({\n      collectionName: migration.collectionName,\n      options: migration.options\n    })) {\n      migrate(migration.collectionName, migration.cacheField);\n      MigrationHistory.insert({\n        collectionName: migration.collectionName,\n        options: migration.options,\n        date: new Date()\n      });\n    }\n  });\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"lodash\":{\"package.json\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// node_modules/meteor/herteby_denormalize/node_modules/lodash/package.json                               //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.exports = {\n  \"name\": \"lodash\",\n  \"version\": \"4.17.4\",\n  \"main\": \"lodash.js\"\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lodash.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// node_modules/meteor/herteby_denormalize/node_modules/lodash/lodash.js                                  //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nmodule.useNode();\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/herteby:denormalize/cache.js\");\nrequire(\"/node_modules/meteor/herteby:denormalize/cacheCount.js\");\nrequire(\"/node_modules/meteor/herteby:denormalize/cacheField.js\");\n\n/* Exports */\nPackage._define(\"herteby:denormalize\", exports);\n\n})();\n","servePath":"/packages/herteby_denormalize.js","sourceMap":{"version":3,"sources":["packages/herteby:denormalize/cache.js","packages/herteby:denormalize/cacheCount.js","packages/herteby:denormalize/cacheField.js","packages/herteby:denormalize/migrations.js"],"names":["module","export","migrate","autoMigrate","_","link","default","v","addMigration","flattenFields","object","prefix","fields","each","val","key","union","push","Mongo","Collection","prototype","cache","options","check","collection","Match","Where","OneOf","String","Object","type","referenceField","cacheField","bypassSchema","Optional","Boolean","parentCollection","Package","_collection","childCollection","watchedFields","split","Error","isArray","childFields","clone","includes","pull","childOpts","transform","_id","field","parentOpts","idField","referencePath","replace","topFields","uniq","map","getNestedReferences","document","references","get","length","item","flatten","insert","userId","parent","child","findOne","update","$set","after","changedFields","$unset","pickedChild","pick","multi","intersection","remove","children","find","$in","fetch","$push","forEach","index","findIndex","$pull","previousId","previous","previousIds","difference","cacheCount","selector","keys","ref","select","merge","count","Function","doc","compact","join","insertHook","userid","Meteor","defer","MigrationHistory","settings","migrations","insertFn","opts","_name","JSON","stringify","collectionName","fn","migration","time","Date","n","console","log","date"],"mappings":"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","file":"/packages/herteby_denormalize.js","sourcesContent":["import _ from 'lodash'\nimport {addMigration, migrate, autoMigrate} from './migrations.js'\n\nexport {migrate, autoMigrate}\n\nfunction flattenFields(object, prefix){\n  prefix = prefix || ''\n  let fields = []\n  _.each(object, (val, key) => {\n    if(typeof val == 'object'){\n      fields = _.union(fields, flattenFields(val, prefix + key + '.'))\n    } else {\n      fields.push(prefix + key)\n    }\n  })\n  return fields\n}\n\nMongo.Collection.prototype.cache = function(options){\n  check(options, {\n    collection:Match.Where(collection => collection instanceof Mongo.Collection),\n    fields:Match.OneOf([String], Object),\n    type:Match.OneOf('one', 'many', 'inversed', 'inverse', 'many-inversed', 'many-inverse'),\n    referenceField:String,\n    cacheField:String,\n    bypassSchema:Match.Optional(Boolean)\n  })\n  if(options.type == 'inverse') options.type = 'inversed' //Not sure which is best, so why not support both and be typo-friendly\n  if(options.type == 'many-inverse') options.type = 'many-inversed'\n\n  //Bypass collection2 schemas\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let type = options.type\n  let referenceField = options.referenceField\n  let cacheField = options.cacheField\n  let watchedFields = options.fields\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  if(!_.isArray(watchedFields)){\n    watchedFields = flattenFields(watchedFields)\n  }\n\n  let childFields = _.clone(watchedFields)\n  if(type !== 'one'){\n    if(!_.includes(childFields, '_id')){\n      childFields.push('_id')\n    }\n    _.pull(childFields, referenceField)\n  }\n  let childOpts = {transform:null, fields:{_id:0}}\n  _.each(childFields, field => childOpts.fields[field] = 1)\n\n  let parentOpts = {transform:null, fields:{_id:1, [cacheField]:1}}\n  if(type !== 'inversed' && type !== 'many-inversed'){\n    parentOpts.fields[referenceField.split(':')[0]] = 1\n  }\n\n  let idField, referencePath\n  if(type == 'many' || type == 'many-inversed'){\n    referencePath = referenceField.replace(':', '.')\n    idField = referenceField.split(':')[1]\n    referenceField = referenceField.split(':')[0]\n  }\n\n  if(type == 'inversed' || type == 'many-inversed' && !_.includes(watchedFields, referencePath)){\n    watchedFields.push(referencePath || referenceField)\n  }\n\n  let topFields = _.uniq(watchedFields.map(field => field.split('.')[0]))\n\n  function getNestedReferences(document){ //Used for nested references in \"many\" links\n    let references = _.get(document, referenceField) || []\n    if(idField && references.length){\n      references = _.map(references, item => _.get(item, idField))\n    }\n    return _.uniq(_.flatten(references))\n  }\n\n\n  if(type == 'one'){\n    let insert = function insert(userId, parent){\n      if(_.get(parent, referenceField)){\n        let child = childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        }\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        let child = _.get(parent, referenceField) && childCollection.findOne(_.get(parent, referenceField), childOpts)\n        if(child){\n          parentCollection.update(parent._id, {$set:{[cacheField]:child}})\n        } else {\n          parentCollection.update(parent._id, {$unset:{[cacheField]:1}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({[referenceField]:child._id}, {$set:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referenceField]:child._id}, {$unset:{[cacheField]:1}}, {multi:true})\n    })\n  } \n\n  else if(type == 'many'){\n    let insert = function insert(userId, parent){\n      let references = getNestedReferences(parent)\n      if(references.length){\n        let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      } else {\n        parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n      }\n    }\n    addMigration(parentCollection, insert, options)\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let references = getNestedReferences(parent)\n        if(references.length){\n          let children = childCollection.find({_id:{$in:references}}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      parentCollection.update({[referencePath]:child._id}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        parentCollection.find({[referencePath]:child._id}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({[referencePath]:child._id}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n    })\n  }\n\n\n  else if(type == 'inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referenceField.split('.')[0])){\n        if(_.get(parent, referenceField)){\n          let children = childCollection.find({[referenceField]:parent._id}, childOpts).fetch()\n          parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n        } else {\n          parentCollection.update(parent._id, {$set:{[cacheField]:[]}})\n        }\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let pickedChild = _.pick(child, childFields)\n      if(_.get(child, referenceField)){\n        parentCollection.update({_id:_.get(child, referenceField)}, {$push:{[cacheField]:pickedChild}})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let pickedChild = _.pick(child, childFields)\n        let previousId = this.previous && _.get(this.previous, referenceField)\n        if(previousId && previousId !== _.get(child, referenceField)){\n          parentCollection.update({_id:previousId}, {$pull:{[cacheField]:{_id:child._id}}})\n        }\n        parentCollection.find({_id:_.get(child, referenceField)}, parentOpts).forEach(parent => {\n          let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n          if(index > -1){\n            parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n          } else {\n            parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n          }\n        })\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      parentCollection.update({_id:_.get(child, referenceField)}, {$pull:{[cacheField]:{_id:child._id}}})\n    })\n  }\n\n  else if(type == 'many-inversed'){\n    let insert = function insert(userId, parent){\n      let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n      parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n    }\n    addMigration(parentCollection, insert, options)\n\n    parentCollection.after.insert(insert)\n\n    parentCollection.after.update(function(userId, parent, changedFields){\n      if(_.includes(changedFields, referencePath.split('.')[0])){\n        let children = childCollection.find({[referencePath]:parent._id}, childOpts).fetch()\n        parentCollection.update(parent._id, {$set:{[cacheField]:children}})\n      }\n    })\n\n    childCollection.after.insert(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){        \n        let pickedChild = _.pick(child, childFields)\n        parentCollection.update({_id:{$in:references}}, {$push:{[cacheField]:pickedChild}}, {multi:true})\n      }\n    })\n\n    childCollection.after.update(function(userId, child, changedFields){\n      if(_.intersection(changedFields, topFields).length){\n        let references = getNestedReferences(child)\n        let previousIds = this.previous && getNestedReferences(this.previous)\n        previousIds = _.difference(previousIds, references)\n        if(previousIds.length){\n          parentCollection.update({_id:{$in:previousIds}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n        }\n        if(references.length){\n          let pickedChild = _.pick(child, childFields)\n          parentCollection.find({_id:{$in:references}}, parentOpts).forEach(parent => {\n            let index = _.findIndex(_.get(parent, cacheField), {_id:child._id})\n            if(index > -1){\n              parentCollection.update(parent._id, {$set:{[cacheField + '.' + index]:pickedChild}})\n            } else {\n              parentCollection.update(parent._id, {$push:{[cacheField]:pickedChild}})\n            }\n          })\n        }\n      }\n    })\n\n    childCollection.after.remove(function(userId, child){\n      let references = getNestedReferences(child)\n      if(references.length){\n        parentCollection.update({_id:{$in:references}}, {$pull:{[cacheField]:{_id:child._id}}}, {multi:true})\n      }\n    })\n  }\n}","import _ from 'lodash'\nimport {addMigration} from './migrations.js'\n\nMongo.Collection.prototype.cacheCount = function(options) {\n  check(options, {\n    collection:Mongo.Collection,\n    cacheField:String,\n    referenceField:String,\n    selector:Match.Optional(Object),\n    bypassSchema:Match.Optional(Boolean)\n  })\n\n  let parentCollection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let childCollection = options.collection\n  let selector = options.selector || {}\n  let cacheField = options.cacheField\n  let referenceField = options.referenceField\n  let watchedFields = _.union([referenceField], _.keys(selector))\n\n  if(referenceField.split(/[.:]/)[0] == cacheField.split(/[.:]/)[0]){\n    throw new Error('referenceField and cacheField must not share the same top field')\n  }\n\n  function update(child){\n    let ref = _.get(child, referenceField)\n    if(ref){\n      let select = _.merge(selector, {[referenceField]:ref})\n      parentCollection.update({_id:ref}, {$set:{[cacheField]:childCollection.find(select).count()}})\n    }\n  }\n\n  function insert(userId, parent){\n    let select = _.merge(selector, {[referenceField]:parent._id})\n    parentCollection.update(parent._id, {$set:{[cacheField]:childCollection.find(select).count()}})\n  }\n\n  addMigration(parentCollection, insert, options)\n\n  parentCollection.after.insert(insert)\n  \n  childCollection.after.insert((userId, child) => {\n    update(child)\n  })\n\n  childCollection.after.update((userId, child, changedFields) => {\n    if(_.intersection(changedFields, watchedFields).length){\n      update(child)\n      update(this.previous)\n    }\n  })\n\n  childCollection.after.remove((userId, child) => {\n    update(child)\n  })\n}","import _ from 'lodash'\nimport {addMigration} from './migrations.js'\n\nMongo.Collection.prototype.cacheField = function(options) {\n\n  check(options, {\n    cacheField:String,\n    fields:[String],\n    transform:Match.Optional(Function),\n    bypassSchema:Match.Optional(Boolean)\n  })\n\n  let collection = options.bypassSchema && Package['aldeed:collection2'] ? this._collection : this\n  let cacheField = options.cacheField\n  let fields = options.fields\n  let topFields = _.uniq(_.map(fields, field => field.split('.')[0]))\n  let transform = options.transform\n  if(!transform) {\n    transform = function(doc) {\n      return _.compact(_.map(fields, field => _.get(doc, field))).join(', ')\n    }\n  }\n\n  if(_.includes(topFields, cacheField.split(/[.:]/)[0])){\n    throw new Error('watching the cacheField for changes would cause an infinite loop')\n  }\n\n  function insertHook(userid, doc){\n    collection.update(doc._id, {$set:{[cacheField]:transform(_.pick(doc, fields))}})\n  }\n\n  addMigration(collection, insertHook, options)\n\n  collection.after.insert(insertHook)\n\n  collection.after.update((userId, doc, changedFields) => {\n    if(_.intersection(changedFields, topFields).length){\n      Meteor.defer(()=>{\n        collection.update(doc._id, {$set:{[cacheField]:transform(_.pick(doc, fields))}})\n      })\n    }\n  })  \n}\n","import _ from 'lodash'\nimport {Mongo} from 'meteor/mongo'\nimport settings from './cache.js'\n\nexport const MigrationHistory = new Mongo.Collection('_cacheMigrations')\n\nlet migrations = []\n\nexport function addMigration(collection, insertFn, options){\n  let opts = _.clone(options)\n  if(opts.collection){ //prevent Error: Converting circular structure to JSON\n    opts.collection = opts.collection._name\n  }\n  opts = JSON.stringify(opts)\n  migrations.push({\n    options:opts,\n    collectionName:collection._name,\n    collection:collection,\n    cacheField:options.cacheField,\n    fn:insertFn\n  })\n}\n\nexport function migrate(collectionName, cacheField, selector){\n  let migration = _.find(migrations, {collectionName, cacheField})\n  if(!migration){\n    throw new Error('no migration found for ' + collectionName + ' - ' + cacheField)\n  } else {\n    let time = new Date()\n    let n = 0\n    migration.collection.find(selector || {}).forEach(doc => {\n      migration.fn(null, doc)\n      n++\n    })\n    console.log(`migrated ${cacheField} of ${n} docs in ${collectionName + (selector ? ' matching ' + JSON.stringify(selector) : '')}. It took ${new Date() - time}ms`)\n  }\n}\n\nexport function autoMigrate(){\n  _.each(migrations, migration => {\n    if(!MigrationHistory.findOne({collectionName:migration.collectionName, options:migration.options})){\n      migrate(migration.collectionName, migration.cacheField)\n      MigrationHistory.insert({\n        collectionName:migration.collectionName,\n        options:migration.options,\n        date:new Date()\n      })\n    }    \n  })\n}"]}}]