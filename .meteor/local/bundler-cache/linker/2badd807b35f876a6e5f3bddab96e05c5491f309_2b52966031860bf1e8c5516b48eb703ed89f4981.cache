[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\n\n/* Package-scope variables */\nvar CollectionExtensions;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/lai_collection-extensions/collection-extensions.js                                                   //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n// The collection extensions namespace\nCollectionExtensions = {};\n\n// Stores all the collection extensions\nCollectionExtensions._extensions = [];\n\n// This is where you would add custom functionality to\n// Mongo.Collection/Meteor.Collection\nCollectionExtensions.addExtension = function(customFunction) {\n  if (typeof customFunction !== 'function') {\n    throw new Meteor.Error(\n      'collection-extension-wrong-argument', \n      'You must pass a function \\\n       into CollectionExtensions.addExtension().');\n  }\n  CollectionExtensions._extensions.push(customFunction);\n  // If Meteor.users exists, apply the extension right away\n  if (typeof Meteor.users !== 'undefined') {\n    customFunction.apply(Meteor.users, ['users']);\n  }\n};\n\n// Backwards compatibility\nMeteor.addCollectionExtension = function() {\n  console.warn('`Meteor.addCollectionExtension` is deprecated, please use `CollectionExtensions.addExtension`');\n  CollectionExtensions.addExtension.apply(null, arguments);\n};\n\n// Utility function to add a prototype function to your\n// Meteor/Mongo.Collection object\nCollectionExtensions.addPrototype = function(name, customFunction) {\n  if (typeof name !== 'string') {\n    throw new Meteor.Error(\n      'collection-extension-wrong-argument', \n      'You must pass a string as the first argument \\\n       into CollectionExtensions.addPrototype().');\n  }\n  if (typeof customFunction !== 'function') {\n    throw new Meteor.Error(\n      'collection-extension-wrong-argument', \n      'You must pass a function as the second argument \\\n       into CollectionExtensions.addPrototype().');\n  }\n  (typeof Mongo !== 'undefined' ? \n    Mongo.Collection : \n    Meteor.Collection).prototype[name] = customFunction;\n};\n\n// Backwards compatibility\nMeteor.addCollectionPrototype = function() {\n  console.warn('`Meteor.addCollectionPrototype` is deprecated, please use `CollectionExtensions.addPrototype`');\n  CollectionExtensions.addPrototype.apply(null, arguments);\n};\n\n// This is used to reassign the prototype of unfortunately \n// and unstoppably already instantiated Mongo instances\n// i.e. Meteor.users\nfunction reassignCollectionPrototype(instance, constr) {\n  var hasSetPrototypeOf = typeof Object.setPrototypeOf === 'function';\n\n  if (!constr) constr = typeof Mongo !== 'undefined' ? Mongo.Collection : Meteor.Collection;\n\n  // __proto__ is not available in < IE11\n  // Note: Assigning a prototype dynamically has performance implications\n  if (hasSetPrototypeOf) {\n    Object.setPrototypeOf(instance, constr.prototype);\n  } else if (instance.__proto__) {\n    instance.__proto__ = constr.prototype;\n  }\n};\n\n// This monkey-patches the Collection constructor\n// This code is the same monkey-patching code \n// that matb33:collection-hooks uses, which works pretty nicely\nfunction wrapCollection(ns, as) {\n  // Save the original prototype\n  if (!as._CollectionPrototype) as._CollectionPrototype = new as.Collection(null);\n\n  var constructor = as.Collection;\n  var proto = as._CollectionPrototype;\n\n  ns.Collection = function () {\n    var ret = constructor.apply(this, arguments);\n    // This is where all the collection extensions get processed\n    processCollectionExtensions(this, arguments);\n    return ret;\n  };\n\n  ns.Collection.prototype = proto;\n  ns.Collection.prototype.constructor = ns.Collection;\n\n  for (var prop in constructor) {\n    if (constructor.hasOwnProperty(prop)) {\n      ns.Collection[prop] = constructor[prop];\n    }\n  }\n};\n\nfunction processCollectionExtensions(self, args) {\n  // Using old-school operations for better performance\n  // Please don't judge me ;P\n  var args = args ? [].slice.call(args, 0) : undefined;\n  var extensions = CollectionExtensions._extensions;\n  for (var i = 0, len = extensions.length; i < len; i++) {\n    extensions[i].apply(self, args);\n  }\n};\n\nif (typeof Mongo !== 'undefined') {\n  wrapCollection(Meteor, Mongo);\n  wrapCollection(Mongo, Mongo);\n} else {\n  wrapCollection(Meteor, Meteor);\n}\n\nif (typeof Meteor.users !== 'undefined') {\n  // Ensures that Meteor.users instanceof Mongo.Collection\n  reassignCollectionPrototype(Meteor.users);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"lai:collection-extensions\", {\n  CollectionExtensions: CollectionExtensions\n});\n\n})();\n","servePath":"/packages/lai_collection-extensions.js"}]